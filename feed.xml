<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:3798/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:3798/" rel="alternate" type="text/html" /><updated>2019-06-20T16:56:09+08:00</updated><id>http://localhost:3798/feed.xml</id><title type="html">slongle</title><subtitle></subtitle><author><name>slongle</name><email>junchendeng@gmail.com</email></author><entry><title type="html">Software Construction Ch10</title><link href="http://localhost:3798/2019/06/20/Software-Construction-Ch10.html" rel="alternate" type="text/html" title="Software Construction Ch10" /><published>2019-06-20T00:00:00+08:00</published><updated>2019-06-20T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/20/Software%20Construction%20Ch10</id><content type="html" xml:base="http://localhost:3798/2019/06/20/Software-Construction-Ch10.html">&lt;h2 id=&quot;java中多线程的状态及转移&quot;&gt;Java中多线程的状态及转移&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/tTwXyz1x/0034.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadstart和threadrun的区别&quot;&gt;Thread.start()和Thread.run()的区别&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Thread.start()只能被调用一次，而Thread.run()可以被调用多次&lt;/li&gt;
  &lt;li&gt;Thread.start()是真正的多线程，在得到cpu的time slice时，开始执行run()方法；而Thread.run()只是一个函数，当Thread.run()被调用时，程序顺序执行Thread.run()的内容，执行结束后才会继续执行后面的内容
    &lt;h2 id=&quot;主动改变线程状态的方法&quot;&gt;主动改变线程状态的方法&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread.sleep()&lt;br /&gt;
注意，Thread.sleep()需要处理InterruptedException异常&lt;/li&gt;
  &lt;li&gt;Thread.interrupt()&lt;br /&gt;
注意，Thread.interrupted()只会在Thread.sleep()时或者使用Thread.interrupted()/Thread.currentThread().isInterrupted()时检测，否则即使外界调用Thread.interrupt()，线程仍然继续执行&lt;br /&gt;
举例来说，下面的代码不会停止，会一直输出”Running”
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Running&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;想要接收到interrupt信号需要下面这种写法&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Running&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;或者&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Running&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;thread-safe&quot;&gt;Thread Safe&lt;/h2&gt;
    &lt;h3 id=&quot;confinement&quot;&gt;Confinement&lt;/h3&gt;
    &lt;p&gt;线程之间不共享mutable数据(避免使用mutable的全局变量)&lt;/p&gt;
    &lt;h3 id=&quot;immutability&quot;&gt;Immutability&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;No mutator methods&lt;/li&gt;
  &lt;li&gt;All fields are private and final&lt;/li&gt;
  &lt;li&gt;No representation exposure&lt;/li&gt;
  &lt;li&gt;No mutation whatsoever of mutable objects in the rep not even beneficent mutation
    &lt;h3 id=&quot;threadsafe-data-types&quot;&gt;Threadsafe Data Types&lt;/h3&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;synchronizedMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;即使在线程安全的ADT上，使用 iterator也是不安全的&lt;/p&gt;
    &lt;h3 id=&quot;lock&quot;&gt;Lock&lt;/h3&gt;
    &lt;p&gt;使用synchronized
使用方法：&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;等价于&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;死锁deadlock&quot;&gt;死锁(Deadlock)&lt;/h2&gt;
&lt;p&gt;如下图所示，当T1进入锁定a，T2进入锁定b后，T1和T2进入死锁&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/kg4hzHJF/0035.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
如何判断死锁？&lt;br /&gt;
两个进程有T1和T2，锁的序列为S1和S2，取S1和S2的任意两个前缀P1和P2(P1∩P2为空)，以及相应的下一位N1和N2。&lt;br /&gt;
若N1$\in$P2且N2$\in$P1则N1和N2死锁。&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">Java中多线程的状态及转移 Thread.start()和Thread.run()的区别 Thread.start()只能被调用一次，而Thread.run()可以被调用多次 Thread.start()是真正的多线程，在得到cpu的time slice时，开始执行run()方法；而Thread.run()只是一个函数，当Thread.run()被调用时，程序顺序执行Thread.run()的内容，执行结束后才会继续执行后面的内容 主动改变线程状态的方法 Thread.sleep() 注意，Thread.sleep()需要处理InterruptedException异常 Thread.interrupt() 注意，Thread.interrupted()只会在Thread.sleep()时或者使用Thread.interrupted()/Thread.currentThread().isInterrupted()时检测，否则即使外界调用Thread.interrupt()，线程仍然继续执行 举例来说，下面的代码不会停止，会一直输出”Running” Thread a=new Thread(new Runnable() { @Override public void run() { while(true){ System.out.println(&quot;Running&quot;); } } }); a.start(); a.interrupt(); 想要接收到interrupt信号需要下面这种写法 Thread a=new Thread(new Runnable() { @Override public void run() { while(!Thread.interrupted()){ System.out.println(&quot;Running&quot;); } } }); a.start(); a.interrupt(); 或者 Thread a = new Thread(new Runnable() { @Override public void run() { try { while (true) { System.out.println(&quot;Running&quot;); Thread.sleep(100); } } catch (InterruptedException ie){ } } }); a.start(); a.interrupt(); Thread Safe Confinement 线程之间不共享mutable数据(避免使用mutable的全局变量) Immutability No mutator methods All fields are private and final No representation exposure No mutation whatsoever of mutable objects in the rep not even beneficent mutation Threadsafe Data Types private static Map&amp;lt;Integer,Boolean&amp;gt; cache = Collections.synchronizedMap(new HashMap&amp;lt;&amp;gt;()); 即使在线程安全的ADT上，使用 iterator也是不安全的 Lock 使用synchronized 使用方法： public void foo(){ synchronized(this){ ... } } 等价于 public synchronized void foo(){ ... } 死锁(Deadlock) 如下图所示，当T1进入锁定a，T2进入锁定b后，T1和T2进入死锁 如何判断死锁？ 两个进程有T1和T2，锁的序列为S1和S2，取S1和S2的任意两个前缀P1和P2(P1∩P2为空)，以及相应的下一位N1和N2。 若N1$\in$P2且N2$\in$P1则N1和N2死锁。</summary></entry><entry><title type="html">Monte Carlo Methods for Volumetric Light Transport Simulation</title><link href="http://localhost:3798/2019/05/09/Monte-Carlo-Methods-for-Volumetric-Light-Transport-Simulation.html" rel="alternate" type="text/html" title="Monte Carlo Methods for Volumetric Light Transport Simulation" /><published>2019-05-09T00:00:00+08:00</published><updated>2019-05-09T00:00:00+08:00</updated><id>http://localhost:3798/2019/05/09/Monte%20Carlo%20Methods%20for%20Volumetric%20Light%20Transport%20Simulation</id><content type="html" xml:base="http://localhost:3798/2019/05/09/Monte-Carlo-Methods-for-Volumetric-Light-Transport-Simulation.html">&lt;h2 id=&quot;section-2-optical-properties&quot;&gt;Section 2. Optical Properties&lt;/h2&gt;

&lt;h3 id=&quot;collision-coefficient&quot;&gt;Collision Coefficient&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;density per unit volume: $\rho (m^{-3})$&lt;/li&gt;
  &lt;li&gt;cross sectional area: $\sigma_{s}, \sigma_{a} (m^2)$&lt;/li&gt;
  &lt;li&gt;scattering(absorption) coefficient: $\mu_{s}(\mu_{a})=\sigma_{s}(\sigma_{a}) \cdot \rho (m^{-1})$&lt;/li&gt;
  &lt;li&gt;extinction coefficient: $\mu_{t}=\mu_{s}+\mu_{a}$&lt;/li&gt;
  &lt;li&gt;single-scattering albedo: $\alpha=\frac{\mu_{s}}{\mu_{t}}$&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;phase-function&quot;&gt;Phase Function&lt;/h3&gt;

&lt;p&gt;Examples: Henyey-Greenstein, Rayleigh, Lorenz-Mie.&lt;/p&gt;

&lt;p&gt;For more details in &lt;em&gt;Handbook of Digital Image Synthesis: Scientific Foundations of Rendering&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3-volumetric-rendering-equation&quot;&gt;Section 3. Volumetric Rendering Equation&lt;/h2&gt;

&lt;h3 id=&quot;radiative-transfer-equation-rte&quot;&gt;Radiative Transfer Equation (RTE)&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\omega\cdot\nabla)\cdot L(x,\omega)=-\mu_{t}(x)L(x,\omega)+\mu_{a}(x)L_{e}(x,\omega)+\mu_{s}(x)L_{s}(x,\omega)&lt;/script&gt;

&lt;p&gt;Then, this differential equation can yield&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L(x,\omega)=\int_{0}^{\infty}T(x,y)[\mu_{a}(y)L_{e}(y,\omega)+\mu_{s}(y)L_{s}(y,\omega)]dt&lt;/script&gt;

&lt;p&gt;Here, $y=x-t\cdot\omega$, $T(x,y)=e^{-\int_{x}^{y}\mu_{t}(z)dz}$(Beer Lambert Law)&lt;/p&gt;

&lt;h3 id=&quot;volume-rendering-equation&quot;&gt;Volume Rendering Equation&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L(x,\omega)=\int_{0}^{dist}T(x,y)[\mu_{a}(y)L_{e}(y,\omega)+\mu_{s}(y)L_{s}(y,\omega)]dt+T(x,z)L(z,\omega)&lt;/script&gt;

&lt;p&gt;Here,$z=x-dist\cdot \omega$&lt;/p&gt;

&lt;h3 id=&quot;path-integral-formulation&quot;&gt;Path Integral Formulation&lt;/h3&gt;

&lt;p&gt;$\overline{x_{k}}={x_0,x_1,\dots,x_k}$, the $x_0$ is the point on the sensor&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(\overline{x_{k}})=W(x_0,x_1)G(x_0,x_1)T(x_0,x_1)\cdot L_{e}(x_k\rightarrow x_{k-1})\cdot \prod_{i=1}^{i=k-1}f_{s}(x_{i+1}\rightarrow x_{i}\rightarrow x_{i-1})G(x_{i},x_{i+1})T(x_{i},x_{i+1})&lt;/script&gt;

&lt;p&gt;$W$ is response of the point on the sensor&lt;/p&gt;

&lt;p&gt;$G(x,y)=\frac{D(x,y)\cdot D(y,x)}{\Vert x-y\Vert ^2}$&lt;/p&gt;

&lt;p&gt;$D(x,y)=\begin{cases} \vert n(x)\cdot \omega_{x\rightarrow y}\vert &amp;amp; \text{x is on a surface} \newline 1 &amp;amp; \text{x is in a medium} \end{cases}$&lt;/p&gt;

&lt;p&gt;$f_{x\rightarrow y\rightarrow z}=\begin{cases} f_{r}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is on a surface} \newline \mu_{s}(y)\cdot f_{p}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is in a medium} \end{cases}$&lt;/p&gt;

&lt;p&gt;$L_{e}(x\rightarrow y)=\begin{cases} L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is on a surface} \newline \mu_{a}(x)L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is in a medium}\end{cases}$&lt;/p&gt;

&lt;h2 id=&quot;section-4-distance-sampling&quot;&gt;Section 4. Distance Sampling&lt;/h2&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Computer-Graphics" /><summary type="html">Section 2. Optical Properties Collision Coefficient density per unit volume: $\rho (m^{-3})$ cross sectional area: $\sigma_{s}, \sigma_{a} (m^2)$ scattering(absorption) coefficient: $\mu_{s}(\mu_{a})=\sigma_{s}(\sigma_{a}) \cdot \rho (m^{-1})$ extinction coefficient: $\mu_{t}=\mu_{s}+\mu_{a}$ single-scattering albedo: $\alpha=\frac{\mu_{s}}{\mu_{t}}$ Phase Function Examples: Henyey-Greenstein, Rayleigh, Lorenz-Mie. For more details in Handbook of Digital Image Synthesis: Scientific Foundations of Rendering Section 3. Volumetric Rendering Equation Radiative Transfer Equation (RTE) Then, this differential equation can yield Here, $y=x-t\cdot\omega$, $T(x,y)=e^{-\int_{x}^{y}\mu_{t}(z)dz}$(Beer Lambert Law) Volume Rendering Equation Here,$z=x-dist\cdot \omega$ Path Integral Formulation $\overline{x_{k}}={x_0,x_1,\dots,x_k}$, the $x_0$ is the point on the sensor $W$ is response of the point on the sensor $G(x,y)=\frac{D(x,y)\cdot D(y,x)}{\Vert x-y\Vert ^2}$ $D(x,y)=\begin{cases} \vert n(x)\cdot \omega_{x\rightarrow y}\vert &amp;amp; \text{x is on a surface} \newline 1 &amp;amp; \text{x is in a medium} \end{cases}$ $f_{x\rightarrow y\rightarrow z}=\begin{cases} f_{r}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is on a surface} \newline \mu_{s}(y)\cdot f_{p}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is in a medium} \end{cases}$ $L_{e}(x\rightarrow y)=\begin{cases} L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is on a surface} \newline \mu_{a}(x)L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is in a medium}\end{cases}$ Section 4. Distance Sampling</summary></entry><entry><title type="html">Last Time</title><link href="http://localhost:3798/2019/04/10/Last-Time.html" rel="alternate" type="text/html" title="Last Time" /><published>2019-04-10T00:00:00+08:00</published><updated>2019-04-10T00:00:00+08:00</updated><id>http://localhost:3798/2019/04/10/Last%20Time</id><content type="html" xml:base="http://localhost:3798/2019/04/10/Last-Time.html">&lt;h2 id=&quot;todolist&quot;&gt;ToDoList：&lt;/h2&gt;
&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1A 250&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1A 500&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;TCO14 Round 1A 1000&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;TCO14 Round 1B 200&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1B 600&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1B 900&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1C 250&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1C 450&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1C 950&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 2A 250&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 2A 500&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;TCO14 Round 2A 1000&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 2B 350&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 2B 500&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;TCO14 Round 2B 900&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;topcoder&quot;&gt;Topcoder&lt;/h2&gt;

&lt;h3 id=&quot;srm-754&quot;&gt;SRM 754&lt;/h3&gt;
&lt;h4 id=&quot;medium&quot;&gt;Medium&lt;/h4&gt;
&lt;p&gt;题意 : 给定投影等价类数，构造一组点集方案。&lt;br /&gt;
题解 : 两个点有两个等价类，对于一个点集，$n^2$条直线去重后的个数为等价类数。构造两列点即可。&lt;/p&gt;
&lt;h4 id=&quot;hard&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 给定$4$连通块大小和$8$连通块大小，返回构造结果。&lt;br /&gt;
题解 : $8$连通块是由若干$4$连通块组合起来，状压DP一下，DP出一组解。然后按行构造即可。&lt;/p&gt;

&lt;h3 id=&quot;srm-753&quot;&gt;SRM 753&lt;/h3&gt;
&lt;h4 id=&quot;hard-1&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 给定一个序列，区间询问去掉一个数后的最大异或和。&lt;br /&gt;
题解 : 可持久化Trie树，区间异或和在区间的Trie树上异或出最大值。&lt;/p&gt;

&lt;h3 id=&quot;2019-humblefool-cup-prelims&quot;&gt;2019 Humblefool Cup Prelims&lt;/h3&gt;
&lt;h4 id=&quot;hard-2&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 定义相邻的两个质数为只有一个数位不同，且长度相同。询问两个质数可以到达。&lt;br /&gt;
题解 : 质数非常连通，预处理之后会发现，只有$4$个块，$2$个是孤点，还有$1$个是大小为$2$的块，剩下的点全部联通。&lt;/p&gt;

&lt;h3 id=&quot;srm-752&quot;&gt;SRM 752&lt;/h3&gt;
&lt;h4 id=&quot;hard-3&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 有$n$个硬币在桌子上，有$1$个硬币在手里，每次抛硬币，正面的话桌面上加$1$个硬币，手里留$1$个硬币，如果桌上有$2N$个硬币则游戏结束。反面的话，从桌上硬币拿走手里的硬币数个放到手里，如果桌上拿空则游戏结束。输出期望场数。&lt;br /&gt;
题解 : 转移显然有环，但是由于正面的特殊性，定义$f[i]$表示手里$1$个硬币，桌上$i$个硬币的期望场数。转移方程$f[i]=(f[i+1]+1)*0.5+(f[i]+2)*0.5^2+(f[i-2]+3)*0.5^3+\cdots$。可以发现转移有后效性，但是我们可以将$f[i+1]$去除后效性。&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-1b&quot;&gt;TCO 2014 Round 1B&lt;/h3&gt;
&lt;h4 id=&quot;medium-wolvesandsheep&quot;&gt;Medium WolvesAndSheep&lt;/h4&gt;
&lt;p&gt;贪心反例：&lt;br /&gt;
x[]&lt;br /&gt;
[]v&lt;br /&gt;
纯贪心（按行和列分别做一次），不会分割，所以x还是能到达v。&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-1b-1&quot;&gt;TCO 2014 Round 1B&lt;/h3&gt;
&lt;h4 id=&quot;hard-eagleinzoo&quot;&gt;Hard EagleInZoo&lt;/h4&gt;
&lt;p&gt;题意：给定一棵树，从根节点放入动物，如果这个节点已经有动物了，就等概率的选择子节点往下走，重复过程直到有空节点或离开树，一旦离开树，这次的过程停止。询问放入$m$个动物，最后一只留在树上的概率。  &lt;br /&gt;
题解：关键：设计状态转移时，要让转移的方案不相交。&lt;br /&gt;
$dp[i][j]$表示以$i$为根的子树，放入$j$个动物，最后一只能够留在树上的概率。&lt;br /&gt;
转移的时候考虑最后一个动物留在哪个子树，这样使得转移的方案不相交。&lt;br /&gt;
假设以$i$为根的子树放入$j$个动物，$i$的子节点数为$c$，枚举进入某个个子树$ch$的动物数$k$，那么概率为${\frac{1}{c}}^{k}*(1-\frac{1}{c})^{j-1-k}*C_{j-2}^{k-1}$
不管进入别的$ch$的情况是怎么样，所以概率是$1-\frac{1}{c}$&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-2a&quot;&gt;TCO 2014 Round 2A&lt;/h3&gt;
&lt;h4 id=&quot;easy-sixteenbricks&quot;&gt;Easy SixteenBricks&lt;/h4&gt;
&lt;p&gt;题意：给定16块$1*1*x[i]$砖，放在$4*4$的格子里，使得可以看见的面积最大。&lt;br /&gt;
题解：关键：首先要大小交替摆放，然后降维分析。&lt;br /&gt;
$a&amp;gt;b&amp;gt;c&amp;gt;d$，考虑一维情况$adbc$比$acbd$更优，因为两个的面积分别是$2a+2b-2d$和$2a+2b-2c$，然后放在二维即可。&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-2a-1&quot;&gt;TCO 2014 Round 2A&lt;/h3&gt;
&lt;h4 id=&quot;medium-narrowpassage&quot;&gt;Medium NarrowPassage&lt;/h4&gt;
&lt;p&gt;题意：在$0$到$l$的走廊里，给定每个物品$n\le 50$的初始位置和目标位置，要改变物品的顺序，必须这些物品在最左端或最右端，询问最小移动步数。&lt;br /&gt;
题解：关键：最优移动的方案。&lt;br /&gt;
首先一种情况是，按最开始的位置分成三段，左边一段全部移到最左边，右边一段全部移到最右边，中间一段自行调整。&lt;br /&gt;
这种情况的要求是，中间段不能交叉，左边和右边那段的目标位置不能跨越中间那段。&lt;br /&gt;
另一种方案是&lt;img src=&quot;http://7xs2ho.com1.z0.glb.clouddn.com/0013.png&quot; alt=&quot;&quot; /&gt;
这类情况的最优方案是，按照起点排序，左边到左端点，右边到右端点，然后按终点排序，枚举边界，右边点的到右端点。&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-2a-2&quot;&gt;TCO 2014 Round 2A&lt;/h3&gt;
&lt;h4 id=&quot;hard-treepuzzle&quot;&gt;Hard TreePuzzle&lt;/h4&gt;
&lt;p&gt;题意：给定一棵树$(n\le 500)$，给定每个点有无黑点，根节点放一个红点，询问哪些点能被红点到达。&lt;br /&gt;
题解：关键：分类讨论啊。&lt;br /&gt;
首先，你现在红点在$x$，黑点分布为$f[x]$，$y$为$x$的一个子节点，判断$y$是否可达。&lt;br /&gt;
1.若$y$的子树中空节点数大于等于$1$，则可达。&lt;br /&gt;
2.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数为$0$，即$x$的子树中无空节点，则不可达。&lt;br /&gt;
3.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数大于等于$2$，则可达。&lt;br /&gt;
4.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数等于$1$，记该节点为$z$，其子树中空节点数为$cnt$。&lt;br /&gt;
找到$z$的子树中离$z$最近的，且度数大于等于$3$的节点$z’$，若$cnt\ge z$到$z’$的节点数+$2$，则可到达，否则不可到达。&lt;/p&gt;

&lt;h2 id=&quot;atcoder&quot;&gt;Atcoder&lt;/h2&gt;
&lt;h3 id=&quot;arc-88&quot;&gt;ARC 88&lt;/h3&gt;
&lt;h4 id=&quot;d-wide-flip&quot;&gt;D Wide Flip&lt;/h4&gt;
&lt;p&gt;题意：给定一个长度为$n$的$01$序列，可以翻转一段连续的长度大于$k$的区间，询问最大的$k$。&lt;br /&gt;
题解：关键：假设我们选定了一个$k$，我们能单独修改某些单独位置。&lt;br /&gt;
修改第$i\ge k+1$位，可以通过修改$[1,i-1]$和$[1,i]$。&lt;br /&gt;
修改第$i\le n-k$位，可以通过修改$[i,n]$和$[i+1,n]$。&lt;br /&gt;
到了第$i$和$i+1$位为$01/10$时，我们要修改第$i$和$i+1$位都能达到我们的目的，所以取一个更大的$k$。&lt;br /&gt;
$0110010010$&lt;br /&gt;
$1\ \ 3\ \ 56\ \ 89\ \ $  &lt;br /&gt;
$9\ \ 7\ \ 54\ \ 21\ \ $  &lt;br /&gt;
可以观察上图，取$\lceil\frac{n}{2}\rceil$一定可以实现目的，因为可以随意修改左右两侧的值，实际上我们要去找的，最靠近中心的01交替的位置，以这个位置对称过去的两侧都可以随意修改，而剩下来中间的部分不用修改。&lt;/p&gt;
&lt;h4 id=&quot;e-papple-sort&quot;&gt;E Papple Sort&lt;/h4&gt;
&lt;p&gt;题意：给定一个字符串，询问通过交换相邻字符，最少几次能变为回文串。  &lt;br /&gt;
题解：关键：&lt;br /&gt;
1.a…a…a…a，第2个a一定不会越过第3个a，也就是说相同字母的相对位置不变。&lt;br /&gt;
2.交换相邻字符我们想到：1)可以转化为任意两个位置的交换2)统计答案为求目标位置的逆序对数。&lt;br /&gt;
现在转化为求目标位置，回文的话可以看成是一层一层的，结合第一点我们可以确定第1个a一定和最后一个a是一个回文对，然后我们考虑两对的情况。&lt;br /&gt;
a..a.b…b&lt;br /&gt;
a..b.a…b&lt;br /&gt;
a..b.b…a&lt;br /&gt;
分为上面三种，其中第三种显然最终a在b外面，第一种一定会先变成第二种。&lt;br /&gt;
而第二种,首先我们假设中间的b和a关于中心对称了，因为不对称要整体平移对于ab谁在外面无影响，然后a在外面我们要右侧a移到右侧b外面，b在外面我们要左侧b移到左侧a外面，因为要对称这两个的操作数是相同的。&lt;br /&gt;
所以根据上面三种情况，我们从左向右扫标记每对最终的位置，求一个逆序对即可。&lt;/p&gt;

&lt;h3 id=&quot;arc-89&quot;&gt;ARC 89&lt;/h3&gt;
&lt;h4 id=&quot;d-checker&quot;&gt;D Checker&lt;/h4&gt;
&lt;p&gt;题解：关键：把每个位置的横纵坐标对$2k$取模。&lt;br /&gt;
做二维前缀和即可。&lt;/p&gt;

&lt;h3 id=&quot;arc-90&quot;&gt;ARC 90&lt;/h3&gt;
&lt;h4 id=&quot;e-avoiding-collision&quot;&gt;E Avoiding Collision&lt;/h4&gt;
&lt;p&gt;题意：给定一张无向图，给定两个点$s$和$t$，两个人分别从$s$和$t$出发，并且都沿着最短路走到$t$和$s$，询问两个人不相遇的方案数。  &lt;br /&gt;
题解：核心是容斥来求，$ans=$最短路对数-到达同一个点的最短路对数-到达同一条边的最短路对数。&lt;br /&gt;
先分别求出$s$和$t$到每个点的距离$dis_{1/2}[i]$和最短路方案数$num_{1/2}[i]$，最短路对数为$num_{1}[t]^2$，枚举点，若能作为最短路上的点且两人到达时间相同则计入，枚举边，若能作为最短路上的边且两人在边上能够相遇则计入。&lt;/p&gt;

&lt;h4 id=&quot;f-number-of-digits&quot;&gt;F Number of Digits&lt;/h4&gt;
&lt;p&gt;题意：定义$f(a)$为$a$在十进制中的位数，给定$S(S\le 10^8)$，询问有多少对$l,r$满足，$\sum_{i=l}^{r}f(i)=S$。  &lt;br /&gt;
题解：首先想到$\text{two-point}$，但是$l,r$的范围很大不适用，但但是我们注意到一个关键的性质，当$l\ge10^7$时，因为$f(i)\ge8,i\in[l,r]$，$l$到$r$的距离小于等于$\frac{S}{8}$，所以会得到$f(r)\le f(l)+1$。我们分情况来看一看。&lt;br /&gt;
$1.f(l)=f(r)$，此时要求$f(l)|S$，方案数为$9*10^{f(l)-1}-\frac{S}{f(l)}+1$。&lt;br /&gt;
$2.f(l)+1=f(r)$，令$t=r-l+1$，$f(l)=\text{len}$，$f(r)=\text{len}+1$，$l$到跨越的距离为$x$，跨越到$r$的距离为$y$，得到等式$S=\text{len}*t+y$，枚举$t$，则$y=S\%t$，$x=t-S\%t$，若$x，y$都大于$0$则计入答案&lt;/p&gt;

&lt;h2 id=&quot;codeforces&quot;&gt;Codeforces&lt;/h2&gt;

&lt;h3 id=&quot;educational-codeforces-round-63&quot;&gt;Educational Codeforces Round 63&lt;/h3&gt;
&lt;h4 id=&quot;f-delivery-oligopoly&quot;&gt;F Delivery Oligopoly&lt;/h4&gt;
&lt;p&gt;题意：给一张$n(n\le 15)$个点，$m$条边的双连通图。询问删除最多的边使得新图为双连通图的方案。&lt;br /&gt;
题解：对于一个双连通图，双连通块的构造方法是一个双连通块加上一条链/一个点。那么我们枚举双连通块点集$s$，枚举一个端点为$i,j$且点集为$t$的链，使得$i,j$分别与$s$内两点相连。&lt;br /&gt;
预处理出$i$到点集$s(i\not\in s)$的最大/次大距离，预处理出点集为$s$，左右端点为$i$和$j$的链的最小花费。转移记录方案。 &lt;br /&gt;
复杂度$O(3^n*n^2)$。&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Algorithm" /><summary type="html">ToDoList： TCO14 Round 1A 250 TCO14 Round 1A 500 TCO14 Round 1A 1000 TCO14 Round 1B 200 TCO14 Round 1B 600 TCO14 Round 1B 900 TCO14 Round 1C 250 TCO14 Round 1C 450 TCO14 Round 1C 950 TCO14 Round 2A 250 TCO14 Round 2A 500 TCO14 Round 2A 1000 TCO14 Round 2B 350 TCO14 Round 2B 500 TCO14 Round 2B 900 Topcoder SRM 754 Medium 题意 : 给定投影等价类数，构造一组点集方案。 题解 : 两个点有两个等价类，对于一个点集，$n^2$条直线去重后的个数为等价类数。构造两列点即可。 Hard 题意 : 给定$4$连通块大小和$8$连通块大小，返回构造结果。 题解 : $8$连通块是由若干$4$连通块组合起来，状压DP一下，DP出一组解。然后按行构造即可。 SRM 753 Hard 题意 : 给定一个序列，区间询问去掉一个数后的最大异或和。 题解 : 可持久化Trie树，区间异或和在区间的Trie树上异或出最大值。 2019 Humblefool Cup Prelims Hard 题意 : 定义相邻的两个质数为只有一个数位不同，且长度相同。询问两个质数可以到达。 题解 : 质数非常连通，预处理之后会发现，只有$4$个块，$2$个是孤点，还有$1$个是大小为$2$的块，剩下的点全部联通。 SRM 752 Hard 题意 : 有$n$个硬币在桌子上，有$1$个硬币在手里，每次抛硬币，正面的话桌面上加$1$个硬币，手里留$1$个硬币，如果桌上有$2N$个硬币则游戏结束。反面的话，从桌上硬币拿走手里的硬币数个放到手里，如果桌上拿空则游戏结束。输出期望场数。 题解 : 转移显然有环，但是由于正面的特殊性，定义$f[i]$表示手里$1$个硬币，桌上$i$个硬币的期望场数。转移方程$f[i]=(f[i+1]+1)*0.5+(f[i]+2)*0.5^2+(f[i-2]+3)*0.5^3+\cdots$。可以发现转移有后效性，但是我们可以将$f[i+1]$去除后效性。 TCO 2014 Round 1B Medium WolvesAndSheep 贪心反例： x[] []v 纯贪心（按行和列分别做一次），不会分割，所以x还是能到达v。 TCO 2014 Round 1B Hard EagleInZoo 题意：给定一棵树，从根节点放入动物，如果这个节点已经有动物了，就等概率的选择子节点往下走，重复过程直到有空节点或离开树，一旦离开树，这次的过程停止。询问放入$m$个动物，最后一只留在树上的概率。 题解：关键：设计状态转移时，要让转移的方案不相交。 $dp[i][j]$表示以$i$为根的子树，放入$j$个动物，最后一只能够留在树上的概率。 转移的时候考虑最后一个动物留在哪个子树，这样使得转移的方案不相交。 假设以$i$为根的子树放入$j$个动物，$i$的子节点数为$c$，枚举进入某个个子树$ch$的动物数$k$，那么概率为${\frac{1}{c}}^{k}*(1-\frac{1}{c})^{j-1-k}*C_{j-2}^{k-1}$ 不管进入别的$ch$的情况是怎么样，所以概率是$1-\frac{1}{c}$ TCO 2014 Round 2A Easy SixteenBricks 题意：给定16块$1*1*x[i]$砖，放在$4*4$的格子里，使得可以看见的面积最大。 题解：关键：首先要大小交替摆放，然后降维分析。 $a&amp;gt;b&amp;gt;c&amp;gt;d$，考虑一维情况$adbc$比$acbd$更优，因为两个的面积分别是$2a+2b-2d$和$2a+2b-2c$，然后放在二维即可。 TCO 2014 Round 2A Medium NarrowPassage 题意：在$0$到$l$的走廊里，给定每个物品$n\le 50$的初始位置和目标位置，要改变物品的顺序，必须这些物品在最左端或最右端，询问最小移动步数。 题解：关键：最优移动的方案。 首先一种情况是，按最开始的位置分成三段，左边一段全部移到最左边，右边一段全部移到最右边，中间一段自行调整。 这种情况的要求是，中间段不能交叉，左边和右边那段的目标位置不能跨越中间那段。 另一种方案是 这类情况的最优方案是，按照起点排序，左边到左端点，右边到右端点，然后按终点排序，枚举边界，右边点的到右端点。 TCO 2014 Round 2A Hard TreePuzzle 题意：给定一棵树$(n\le 500)$，给定每个点有无黑点，根节点放一个红点，询问哪些点能被红点到达。 题解：关键：分类讨论啊。 首先，你现在红点在$x$，黑点分布为$f[x]$，$y$为$x$的一个子节点，判断$y$是否可达。 1.若$y$的子树中空节点数大于等于$1$，则可达。 2.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数为$0$，即$x$的子树中无空节点，则不可达。 3.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数大于等于$2$，则可达。 4.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数等于$1$，记该节点为$z$，其子树中空节点数为$cnt$。 找到$z$的子树中离$z$最近的，且度数大于等于$3$的节点$z’$，若$cnt\ge z$到$z’$的节点数+$2$，则可到达，否则不可到达。 Atcoder ARC 88 D Wide Flip 题意：给定一个长度为$n$的$01$序列，可以翻转一段连续的长度大于$k$的区间，询问最大的$k$。 题解：关键：假设我们选定了一个$k$，我们能单独修改某些单独位置。 修改第$i\ge k+1$位，可以通过修改$[1,i-1]$和$[1,i]$。 修改第$i\le n-k$位，可以通过修改$[i,n]$和$[i+1,n]$。 到了第$i$和$i+1$位为$01/10$时，我们要修改第$i$和$i+1$位都能达到我们的目的，所以取一个更大的$k$。 $0110010010$ $1\ \ 3\ \ 56\ \ 89\ \ $ $9\ \ 7\ \ 54\ \ 21\ \ $ 可以观察上图，取$\lceil\frac{n}{2}\rceil$一定可以实现目的，因为可以随意修改左右两侧的值，实际上我们要去找的，最靠近中心的01交替的位置，以这个位置对称过去的两侧都可以随意修改，而剩下来中间的部分不用修改。 E Papple Sort 题意：给定一个字符串，询问通过交换相邻字符，最少几次能变为回文串。 题解：关键： 1.a…a…a…a，第2个a一定不会越过第3个a，也就是说相同字母的相对位置不变。 2.交换相邻字符我们想到：1)可以转化为任意两个位置的交换2)统计答案为求目标位置的逆序对数。 现在转化为求目标位置，回文的话可以看成是一层一层的，结合第一点我们可以确定第1个a一定和最后一个a是一个回文对，然后我们考虑两对的情况。 a..a.b…b a..b.a…b a..b.b…a 分为上面三种，其中第三种显然最终a在b外面，第一种一定会先变成第二种。 而第二种,首先我们假设中间的b和a关于中心对称了，因为不对称要整体平移对于ab谁在外面无影响，然后a在外面我们要右侧a移到右侧b外面，b在外面我们要左侧b移到左侧a外面，因为要对称这两个的操作数是相同的。 所以根据上面三种情况，我们从左向右扫标记每对最终的位置，求一个逆序对即可。 ARC 89 D Checker 题解：关键：把每个位置的横纵坐标对$2k$取模。 做二维前缀和即可。 ARC 90 E Avoiding Collision 题意：给定一张无向图，给定两个点$s$和$t$，两个人分别从$s$和$t$出发，并且都沿着最短路走到$t$和$s$，询问两个人不相遇的方案数。 题解：核心是容斥来求，$ans=$最短路对数-到达同一个点的最短路对数-到达同一条边的最短路对数。 先分别求出$s$和$t$到每个点的距离$dis_{1/2}[i]$和最短路方案数$num_{1/2}[i]$，最短路对数为$num_{1}[t]^2$，枚举点，若能作为最短路上的点且两人到达时间相同则计入，枚举边，若能作为最短路上的边且两人在边上能够相遇则计入。 F Number of Digits 题意：定义$f(a)$为$a$在十进制中的位数，给定$S(S\le 10^8)$，询问有多少对$l,r$满足，$\sum_{i=l}^{r}f(i)=S$。 题解：首先想到$\text{two-point}$，但是$l,r$的范围很大不适用，但但是我们注意到一个关键的性质，当$l\ge10^7$时，因为$f(i)\ge8,i\in[l,r]$，$l$到$r$的距离小于等于$\frac{S}{8}$，所以会得到$f(r)\le f(l)+1$。我们分情况来看一看。 $1.f(l)=f(r)$，此时要求$f(l)|S$，方案数为$9*10^{f(l)-1}-\frac{S}{f(l)}+1$。 $2.f(l)+1=f(r)$，令$t=r-l+1$，$f(l)=\text{len}$，$f(r)=\text{len}+1$，$l$到跨越的距离为$x$，跨越到$r$的距离为$y$，得到等式$S=\text{len}*t+y$，枚举$t$，则$y=S\%t$，$x=t-S\%t$，若$x，y$都大于$0$则计入答案 Codeforces Educational Codeforces Round 63 F Delivery Oligopoly 题意：给一张$n(n\le 15)$个点，$m$条边的双连通图。询问删除最多的边使得新图为双连通图的方案。 题解：对于一个双连通图，双连通块的构造方法是一个双连通块加上一条链/一个点。那么我们枚举双连通块点集$s$，枚举一个端点为$i,j$且点集为$t$的链，使得$i,j$分别与$s$内两点相连。 预处理出$i$到点集$s(i\not\in s)$的最大/次大距离，预处理出点集为$s$，左右端点为$i$和$j$的链的最小花费。转移记录方案。 复杂度$O(3^n*n^2)$。</summary></entry><entry><title type="html">Work for Open Source Community Using Git</title><link href="http://localhost:3798/2019/03/19/Work-for-Open-Source-Community-Using-Git.html" rel="alternate" type="text/html" title="Work for Open Source Community Using Git" /><published>2019-03-19T00:00:00+08:00</published><updated>2019-03-19T00:00:00+08:00</updated><id>http://localhost:3798/2019/03/19/Work%20for%20Open%20Source%20Community%20Using%20Git</id><content type="html" xml:base="http://localhost:3798/2019/03/19/Work-for-Open-Source-Community-Using-Git.html">&lt;p&gt;长期更新使用Git和Github工作的内容。&lt;/p&gt;

&lt;h2 id=&quot;案例展示&quot;&gt;案例展示&lt;/h2&gt;
&lt;h3 id=&quot;pr工作流程&quot;&gt;PR工作流程&lt;/h3&gt;
&lt;h4 id=&quot;场景描述&quot;&gt;场景描述&lt;/h4&gt;
&lt;p&gt;第一个场景是大家最常遇到的。 &lt;br /&gt;
先从开源项目那边fork过来，然后clone到本地，准备工作，打算修改完代码再push回去，提交PR。&lt;/p&gt;
&lt;h4 id=&quot;工作流程&quot;&gt;工作流程&lt;/h4&gt;
&lt;p&gt;上面提到的流程听起来非常理想，但是对那些对Git没什么经验的人来说，有非常多的坑存在。&lt;br /&gt;
1.首先我们要时刻保持fork的分支的master分支是与官方的master分支一致。&lt;br /&gt;
2.然后在你本地的master分支上面新建一个new分支，然后在这个new分支上工作。&lt;br /&gt;
前两点很重要，很多人一开始就直接在master分支上面干活，后面会造成非常多的麻烦。&lt;br /&gt;
3.在new分支上干活。&lt;br /&gt;
4.和远程的new分支同步。&lt;br /&gt;
5.在Github上面，你的fork仓库里点击PR，提交PR到官方仓库。&lt;br /&gt;
假设现在我们已经完成工作了，这个PR，我们提交了很多条commit。  &lt;br /&gt;
6.将new分支上的commit，rebase成1条commit到你的master分支，等待merge。  &lt;br /&gt;
在PR被merge后，你的fork分支会落后官方分支，接下来要更新你的fork分支。&lt;br /&gt;
这时我们需要有一个新的merge分支用来merge新的commit，这个merge分支建立在你的master分支上。&lt;br /&gt;
7.点击github上面的compare，比较你的merge分支和官方master分支，将官方master分支上新的commit以PR的形式加到你的merge分支上。&lt;br /&gt;
9.将你merge分支上面的commit以rebase的形式放到你的master分支上。&lt;br /&gt;
10.删除你的merge分支和new分支。&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Git" /><summary type="html">长期更新使用Git和Github工作的内容。 案例展示 PR工作流程 场景描述 第一个场景是大家最常遇到的。 先从开源项目那边fork过来，然后clone到本地，准备工作，打算修改完代码再push回去，提交PR。 工作流程 上面提到的流程听起来非常理想，但是对那些对Git没什么经验的人来说，有非常多的坑存在。 1.首先我们要时刻保持fork的分支的master分支是与官方的master分支一致。 2.然后在你本地的master分支上面新建一个new分支，然后在这个new分支上工作。 前两点很重要，很多人一开始就直接在master分支上面干活，后面会造成非常多的麻烦。 3.在new分支上干活。 4.和远程的new分支同步。 5.在Github上面，你的fork仓库里点击PR，提交PR到官方仓库。 假设现在我们已经完成工作了，这个PR，我们提交了很多条commit。 6.将new分支上的commit，rebase成1条commit到你的master分支，等待merge。 在PR被merge后，你的fork分支会落后官方分支，接下来要更新你的fork分支。 这时我们需要有一个新的merge分支用来merge新的commit，这个merge分支建立在你的master分支上。 7.点击github上面的compare，比较你的merge分支和官方master分支，将官方master分支上新的commit以PR的形式加到你的merge分支上。 9.将你merge分支上面的commit以rebase的形式放到你的master分支上。 10.删除你的merge分支和new分支。</summary></entry></feed>
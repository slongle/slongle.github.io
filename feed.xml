<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:3798/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:3798/" rel="alternate" type="text/html" /><updated>2019-09-15T23:21:12+08:00</updated><id>http://localhost:3798/feed.xml</id><title type="html">slongle</title><subtitle></subtitle><author><name>slongle</name><email>junchendeng@gmail.com</email></author><entry><title type="html">Camke practice</title><link href="http://localhost:3798/2019/09/03/Camke-Practice.html" rel="alternate" type="text/html" title="Camke practice" /><published>2019-09-03T00:00:00+08:00</published><updated>2019-09-03T00:00:00+08:00</updated><id>http://localhost:3798/2019/09/03/Camke%20Practice</id><content type="html" xml:base="http://localhost:3798/2019/09/03/Camke-Practice.html">&lt;h2 id=&quot;cmake-practice&quot;&gt;Cmake Practice&lt;/h2&gt;

&lt;h3 id=&quot;basic-usage&quot;&gt;Basic Usage&lt;/h3&gt;

&lt;h3 id=&quot;third-party&quot;&gt;Third-Party&lt;/h3&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><summary type="html">Cmake Practice Basic Usage Third-Party</summary></entry><entry><title type="html">Software Construction之JVM</title><link href="http://localhost:3798/2019/06/23/Software-Construction-JVM.html" rel="alternate" type="text/html" title="Software Construction之JVM" /><published>2019-06-23T00:00:00+08:00</published><updated>2019-06-23T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/23/Software%20Construction%20JVM</id><content type="html" xml:base="http://localhost:3798/2019/06/23/Software-Construction-JVM.html">&lt;h3 id=&quot;memory&quot;&gt;Memory&lt;/h3&gt;
&lt;p&gt;Stack：所有的局部的primitive和ref变量 &lt;br /&gt;
Heap：所有的Object(局部的Object也是在Heap里，但局部的ref是stack) &lt;br /&gt;
Heap中有Method Area(Metaspace)：类信息，常量，静态变量&lt;/p&gt;
&lt;h3 id=&quot;gc&quot;&gt;GC&lt;/h3&gt;
&lt;h4 id=&quot;mark-sweep&quot;&gt;Mark-Sweep&lt;/h4&gt;
&lt;p&gt;标记是否存活，释放死亡的空间&lt;/p&gt;
&lt;h4 id=&quot;mark-compact&quot;&gt;Mark-Compact&lt;/h4&gt;
&lt;p&gt;标记是否存活，释放死亡的空间，然后碎片整理&lt;/p&gt;
&lt;h4 id=&quot;copy&quot;&gt;Copy&lt;/h4&gt;
&lt;p&gt;标记是否存活，将活的整个复制到另一个空间&lt;/p&gt;
&lt;h4 id=&quot;具体gc&quot;&gt;具体GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/HsRbRbfh/0058.png&quot; alt=&quot;&quot; /&gt;
年轻代：copy算法执行GC&lt;br /&gt;
老年代：Mark-Sweep或Mark-Compact算法执行GC&lt;br /&gt;
当某个区域满时，执行GC&lt;br /&gt;
年轻代执行minor GC，时间较短&lt;br /&gt;
年轻代中经历多轮minor GC后，copy到老年代&lt;br /&gt;
老年代满了之后，老年代执行full GC&lt;/p&gt;
&lt;h4 id=&quot;设置各代空间大小&quot;&gt;设置各代空间大小&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/9QHry13C/0059.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;jvm命令&quot;&gt;JVM命令&lt;/h3&gt;
&lt;h4 id=&quot;jmap&quot;&gt;jmap&lt;/h4&gt;
&lt;p&gt;Heap Configuration:&lt;br /&gt;
   MinHeapFreeRatio         = 0    //JVM最小空闲比率 jvm heap 在使用率小于 n 时 ,heap 进行收缩&lt;br /&gt;
   MaxHeapFreeRatio         = 100  //JVM最大空闲比率 jvm heap 在使用率大于 n 时 ,heap 进行扩张 &lt;br /&gt;
   MaxHeapSize              = 2095054848 (1998.0MB) //JVM堆的最大大小&lt;br /&gt;
   NewSize                  = 44040192 (42.0MB) //JVM新生代的默认大小&lt;br /&gt;
   MaxNewSize               = 698351616 (666.0MB) //JVM新生代的最大大小&lt;br /&gt;
   OldSize                  = 88080384 (84.0MB) //JVM老生代的默认大小 &lt;br /&gt;
   NewRatio                 = 2 //新生代：老生代（的大小）=1:2&lt;br /&gt;
   SurvivorRatio            = 8 //survivor:eden = 1:8,即survivor space是新生代大小的1/(8+2)[因为有两个survivor区域]&lt;br /&gt;
   MetaspaceSize            = 21807104 (20.796875MB) //元空间的默认大小，超过此值就会触发Full GC&lt;br /&gt;
   CompressedClassSpaceSize = 1073741824 (1024.0MB) //类指针压缩空间的默认大小&lt;br /&gt;
   MaxMetaspaceSize         = 17592186044415 MB //元空间的最大大小&lt;br /&gt;
   G1HeapRegionSize         = 0 (0.0MB) //使用G1垃圾收集器的时候，堆被分割的大小&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">Memory Stack：所有的局部的primitive和ref变量 Heap：所有的Object(局部的Object也是在Heap里，但局部的ref是stack) Heap中有Method Area(Metaspace)：类信息，常量，静态变量 GC Mark-Sweep 标记是否存活，释放死亡的空间 Mark-Compact 标记是否存活，释放死亡的空间，然后碎片整理 Copy 标记是否存活，将活的整个复制到另一个空间 具体GC 年轻代：copy算法执行GC 老年代：Mark-Sweep或Mark-Compact算法执行GC 当某个区域满时，执行GC 年轻代执行minor GC，时间较短 年轻代中经历多轮minor GC后，copy到老年代 老年代满了之后，老年代执行full GC 设置各代空间大小 JVM命令 jmap Heap Configuration: MinHeapFreeRatio = 0    //JVM最小空闲比率 jvm heap 在使用率小于 n 时 ,heap 进行收缩 MaxHeapFreeRatio = 100  //JVM最大空闲比率 jvm heap 在使用率大于 n 时 ,heap 进行扩张  MaxHeapSize = 2095054848 (1998.0MB) //JVM堆的最大大小 NewSize = 44040192 (42.0MB) //JVM新生代的默认大小 MaxNewSize = 698351616 (666.0MB) //JVM新生代的最大大小 OldSize = 88080384 (84.0MB) //JVM老生代的默认大小  NewRatio = 2 //新生代：老生代（的大小）=1:2 SurvivorRatio = 8 //survivor:eden = 1:8,即survivor space是新生代大小的1/(8+2)[因为有两个survivor区域] MetaspaceSize = 21807104 (20.796875MB) //元空间的默认大小，超过此值就会触发Full GC CompressedClassSpaceSize = 1073741824 (1024.0MB) //类指针压缩空间的默认大小 MaxMetaspaceSize = 17592186044415 MB //元空间的最大大小 G1HeapRegionSize = 0 (0.0MB) //使用G1垃圾收集器的时候，堆被分割的大小</summary></entry><entry><title type="html">Software Construction之Others</title><link href="http://localhost:3798/2019/06/23/Software-Construction-Others.html" rel="alternate" type="text/html" title="Software Construction之Others" /><published>2019-06-23T00:00:00+08:00</published><updated>2019-06-23T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/23/Software%20Construction%20Others</id><content type="html" xml:base="http://localhost:3798/2019/06/23/Software-Construction-Others.html">&lt;h3 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;$*$:{0,}&lt;/li&gt;
  &lt;li&gt;$+$:{1,}&lt;/li&gt;
  &lt;li&gt;$?$:{0,1}&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;:或&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;^:取补集&lt;/li&gt;
  &lt;li&gt;[bc]等价于[b-c]
    &lt;h3 id=&quot;lsp&quot;&gt;LSP&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;子类型可以增加方法，但不可删&lt;/li&gt;
  &lt;li&gt;子类型需要实现抽象类型中的所有未实现方法&lt;/li&gt;
  &lt;li&gt;子类型中重写的方法必须有相同或子类型的返回值或者符合 co-variance 的参数&lt;/li&gt;
  &lt;li&gt;子类型中重写的方法必须使用同样类型的参数或者符合 contra-variance 的参数&lt;/li&gt;
  &lt;li&gt;子类型中重写的方法不能抛出额外的异常&lt;/li&gt;
  &lt;li&gt;更强的不变量&lt;/li&gt;
  &lt;li&gt;更弱的前置条件&lt;/li&gt;
  &lt;li&gt;更强的后置条件
    &lt;h3 id=&quot;软件构造基础&quot;&gt;软件构造基础&lt;/h3&gt;
    &lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/Y2g37nxw/0060.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;h3 id=&quot;版本控制&quot;&gt;版本控制&lt;/h3&gt;
    &lt;p&gt;SCM : 软件配置管理&lt;br /&gt;
VCS : 版本控制  &lt;br /&gt;
SCI : 软件配置项(软件中发生改变的基本单元，例如:文件)&lt;br /&gt;
CMDB : 配置管理数据库(存储软件的各配置项随时间发生变化的信息)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">正则表达式 $*$:{0,} $+$:{1,} $?$:{0,1} :或 ^:取补集 [bc]等价于[b-c] LSP 子类型可以增加方法，但不可删 子类型需要实现抽象类型中的所有未实现方法 子类型中重写的方法必须有相同或子类型的返回值或者符合 co-variance 的参数 子类型中重写的方法必须使用同样类型的参数或者符合 contra-variance 的参数 子类型中重写的方法不能抛出额外的异常 更强的不变量 更弱的前置条件 更强的后置条件 软件构造基础 版本控制 SCM : 软件配置管理 VCS : 版本控制 SCI : 软件配置项(软件中发生改变的基本单元，例如:文件) CMDB : 配置管理数据库(存储软件的各配置项随时间发生变化的信息)</summary></entry><entry><title type="html">Software Construction之Design Pattern</title><link href="http://localhost:3798/2019/06/22/Software-Construction-Design-Pattern.html" rel="alternate" type="text/html" title="Software Construction之Design Pattern" /><published>2019-06-22T00:00:00+08:00</published><updated>2019-06-22T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/22/Software%20Construction%20Design%20Pattern</id><content type="html" xml:base="http://localhost:3798/2019/06/22/Software-Construction-Design-Pattern.html">&lt;h2 id=&quot;creational-patterns&quot;&gt;Creational patterns&lt;/h2&gt;
&lt;h3 id=&quot;工厂方法模式factory-method-pattern&quot;&gt;工厂方法模式(Factory Method pattern)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/PqH1yTw3/0048.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;抽象工厂模式abstract-factory&quot;&gt;抽象工厂模式(Abstract Factory)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/7Z0gSffJ/0049.png&quot; alt=&quot;&quot; /&gt;
抽象工厂模式和工厂方法模式的区别在于，抽象工厂模式的工厂会创造一个产品的多个组件，而工厂方法模式直接创造一个产品。&lt;/p&gt;
&lt;h3 id=&quot;构造器模式builder&quot;&gt;构造器模式(Builder)&lt;/h3&gt;
&lt;p&gt;Builder抽象类的子类直接build一种产品。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/yxDRxNMd/0050.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;structural-patterns&quot;&gt;Structural patterns&lt;/h2&gt;
&lt;h3 id=&quot;适配器模式adapter&quot;&gt;适配器模式(Adapter)&lt;/h3&gt;
&lt;p&gt;封装为Client方便的形式。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/y6tr73Rw/0042.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;装饰器模式decorator&quot;&gt;装饰器模式(Decorator)&lt;/h3&gt;
&lt;p&gt;将类和类之间嵌套起来，使得到的类包含有之前类的属性和自己的属性。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/HsMvnW4j/0043.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://i.postimg.cc/dVKHyM46/0044.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;外观模式facade&quot;&gt;外观模式(Facade)&lt;/h3&gt;
&lt;p&gt;也是为了Client的方便来封装。&lt;br /&gt;
与Adapter模式不同的是，Facade是将一些过程封装为一个过程，而Adapter是将参数封装。&lt;/p&gt;
&lt;h3 id=&quot;桥接模式bridge&quot;&gt;桥接模式(Bridge)&lt;/h3&gt;
&lt;p&gt;通过委派和继承来实现复杂操作。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/SxhGT60f/0051.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;代理模式proxy&quot;&gt;代理模式(Proxy)&lt;/h3&gt;
&lt;p&gt;为了隔离Client的访问，设置一个代理。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/k5jFgL2T/0052.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;组合模式composite&quot;&gt;组合模式(Composite)&lt;/h3&gt;
&lt;p&gt;类似于装饰器模式，区别在于每个类内部可以有多个其他类的实例而不是只有一个。&lt;/p&gt;
&lt;h2 id=&quot;behavioral-patterns&quot;&gt;Behavioral patterns&lt;/h2&gt;
&lt;h3 id=&quot;策略模式strategy&quot;&gt;策略模式(Strategy)&lt;/h3&gt;
&lt;p&gt;对于策略进行抽象，抽象为Strategy类/接口，然后Strategy中有一个work函数，在子类中实现这个work函数。&lt;br /&gt;
这样只需要切换传入的Strategy是哪个子类就可以了。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/k4VFHwTD/0045.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;模板模式template-method&quot;&gt;模板模式(Template Method)&lt;/h3&gt;
&lt;p&gt;当做事情的步骤一样，但具体方法不同。&lt;br /&gt;
具体来说是，当某个过程work都是由step1(),step2(),step3()这种顺序执行，即&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;step1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;step2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;step3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;但是step1(),step2()可能对于不同的事情具体操作不同，要写成不同的类。&lt;br /&gt;
那么可以在抽象类/接口中实现work()如上，并定义函数step1(),step2()…，然后在继承这个类的不同的类中Override这些step()方法。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/vHyf7Qw4/0046.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;迭代器模式iterator&quot;&gt;迭代器模式(Iterator)&lt;/h3&gt;
&lt;p&gt;对于遍历ADT中的元素，使用Iterator来遍历，不用用户自己去决定怎么遍历。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/y8bDGKtX/0047.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;观察者模式observer&quot;&gt;观察者模式(Observer)&lt;/h3&gt;
&lt;p&gt;有一个被观察者A和很多观察者B1,B2,…。&lt;br /&gt;
Bi先到A那里注册，当A有事件要发布时，A会更新所有观察者的状态。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/2jLFCcrx/0053.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;访问者模式visitor&quot;&gt;访问者模式(Visitor)&lt;/h3&gt;
&lt;p&gt;以类与类的交互形式完成操作。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/4dDcKGsQ/0054.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;中介模式mediator&quot;&gt;中介模式(Mediator)&lt;/h3&gt;
&lt;p&gt;本质上是A与B的交互，现在转化为A与B的中介的交互。&lt;br /&gt;
通过设置中介，使得整个结构耦合度降低。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/bYnb7Z9C/0055.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;命令模式command&quot;&gt;命令模式(Command)&lt;/h3&gt;
&lt;p&gt;通过委派的形式，将命令作用的实例保存在命令里，执行命令即可。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/ZKFNqXg6/0056.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;备忘录模式memento-pattern&quot;&gt;备忘录模式(Memento Pattern)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/L8tx2ykW/0057.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">Creational patterns 工厂方法模式(Factory Method pattern) 抽象工厂模式(Abstract Factory) 抽象工厂模式和工厂方法模式的区别在于，抽象工厂模式的工厂会创造一个产品的多个组件，而工厂方法模式直接创造一个产品。 构造器模式(Builder) Builder抽象类的子类直接build一种产品。 Structural patterns 适配器模式(Adapter) 封装为Client方便的形式。 装饰器模式(Decorator) 将类和类之间嵌套起来，使得到的类包含有之前类的属性和自己的属性。 外观模式(Facade) 也是为了Client的方便来封装。 与Adapter模式不同的是，Facade是将一些过程封装为一个过程，而Adapter是将参数封装。 桥接模式(Bridge) 通过委派和继承来实现复杂操作。 代理模式(Proxy) 为了隔离Client的访问，设置一个代理。 组合模式(Composite) 类似于装饰器模式，区别在于每个类内部可以有多个其他类的实例而不是只有一个。 Behavioral patterns 策略模式(Strategy) 对于策略进行抽象，抽象为Strategy类/接口，然后Strategy中有一个work函数，在子类中实现这个work函数。 这样只需要切换传入的Strategy是哪个子类就可以了。 模板模式(Template Method) 当做事情的步骤一样，但具体方法不同。 具体来说是，当某个过程work都是由step1(),step2(),step3()这种顺序执行，即 public void work(){ step1(); step2(); step3(); } 但是step1(),step2()可能对于不同的事情具体操作不同，要写成不同的类。 那么可以在抽象类/接口中实现work()如上，并定义函数step1(),step2()…，然后在继承这个类的不同的类中Override这些step()方法。 迭代器模式(Iterator) 对于遍历ADT中的元素，使用Iterator来遍历，不用用户自己去决定怎么遍历。 Iterator iterator = adt.iterator(); while (iterator.hasNext()) { Integer item = (Integer) iterator.next(); } 观察者模式(Observer) 有一个被观察者A和很多观察者B1,B2,…。 Bi先到A那里注册，当A有事件要发布时，A会更新所有观察者的状态。 访问者模式(Visitor) 以类与类的交互形式完成操作。 中介模式(Mediator) 本质上是A与B的交互，现在转化为A与B的中介的交互。 通过设置中介，使得整个结构耦合度降低。 命令模式(Command) 通过委派的形式，将命令作用的实例保存在命令里，执行命令即可。 备忘录模式(Memento Pattern)</summary></entry><entry><title type="html">Software Construction之Test and Exception</title><link href="http://localhost:3798/2019/06/22/Software-Construction-Test-and-Exception.html" rel="alternate" type="text/html" title="Software Construction之Test and Exception" /><published>2019-06-22T00:00:00+08:00</published><updated>2019-06-22T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/22/Software%20Construction%20Test%20and%20Exception</id><content type="html" xml:base="http://localhost:3798/2019/06/22/Software-Construction-Test-and-Exception.html">&lt;h2 id=&quot;exception&quot;&gt;Exception&lt;/h2&gt;
&lt;h3 id=&quot;checked-and-unchecked-exception&quot;&gt;checked and unchecked exception&lt;/h3&gt;
&lt;p&gt;checked exception:要handle的exception，如：找不到xxx&lt;br /&gt;
unchecked exception:不handle，直接退出的exception，如&lt;code class=&quot;highlighter-rouge&quot;&gt;Null­Pointer­Exception&lt;/code&gt;&lt;br /&gt;
不用handle的是unchecked，用handle的是checked&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/g2PWRnTQ/0041.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
Exception类是checked exception&lt;br /&gt;
RuntimeException和Error类是unchecked exception&lt;/p&gt;
&lt;h3 id=&quot;javadoc&quot;&gt;Javadoc&lt;/h3&gt;
&lt;p&gt;checked exception需要注释，unchecked exception和error不需要&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * @throws NotPerfectSquareException if x it not a perfect square
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;integerSquareRoot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;定义和抛出异常&quot;&gt;定义和抛出异常&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NotPerfectSquareException&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**
 * @throws NotPerfectSquareException if x it not a perfect square
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;integerSquareRoot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;exception的执行&quot;&gt;Exception的执行&lt;/h3&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;无论怎么执行try和catch，最后都会执行final中的内容&lt;br /&gt;
当A结束时出现异常，如果被捕获就执行C,D，如果没被捕获直接执行D然后退出&lt;/p&gt;
&lt;h2 id=&quot;test&quot;&gt;Test&lt;/h2&gt;
&lt;h3 id=&quot;test-strategy&quot;&gt;Test Strategy&lt;/h3&gt;
&lt;h4 id=&quot;白盒测试&quot;&gt;白盒测试&lt;/h4&gt;
&lt;p&gt;针对代码执行路径设计测试，要求全覆盖&lt;/p&gt;
&lt;h4 id=&quot;黑盒测试&quot;&gt;黑盒测试&lt;/h4&gt;
&lt;p&gt;只考虑spec&lt;/p&gt;
&lt;h5 id=&quot;等价类划分&quot;&gt;等价类划分&lt;/h5&gt;
&lt;p&gt;正负，奇偶，整数非整数，具体某格式和非该格式，长度限制，数据上限&lt;/p&gt;
&lt;h5 id=&quot;考虑边界值&quot;&gt;考虑边界值&lt;/h5&gt;
&lt;p&gt;边界值及边界值附近&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * Testing Strategy
 * 
 * Partition the inputs as follow
 * text.length() : 0, 1, &amp;gt;1
 * start : 0, 1, 1&amp;lt;start&amp;lt;text.length(), text.length()-1, text.length()
 * text.length()-start : 0, 1, even&amp;gt;1, odd&amp;gt;1 
 * 
 * Include ... because ...
 *
 */&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;// cover text.length() = 0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//       start = text.length = 0         &lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Text&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testXXX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">Exception checked and unchecked exception checked exception:要handle的exception，如：找不到xxx unchecked exception:不handle，直接退出的exception，如Null­Pointer­Exception 不用handle的是unchecked，用handle的是checked Exception类是checked exception RuntimeException和Error类是unchecked exception Javadoc checked exception需要注释，unchecked exception和error不需要 /** * @throws NotPerfectSquareException if x it not a perfect square */ int integerSquareRoot(int x) throws NotPerfectSquareException{ ... } 定义和抛出异常 public class NotPerfectSquareException extends Exception { public NotPerfectSquareException() { super(); } public NotPerfectSquareException(String message) { super(message); } public NotPerfectSquareException(String message, Throwable cause) { super(message, cause); } public NotPerfectSquareException(Throwable cause) { super(cause); } } /** * @throws NotPerfectSquareException if x it not a perfect square */ int integerSquareRoot(int x) throws NotPerfectSquareException{ throws new NotPerfectSquareException(); } Exception的执行 try{ A; B; } catch(Exception1 e1){ C; } final{ D; } 无论怎么执行try和catch，最后都会执行final中的内容 当A结束时出现异常，如果被捕获就执行C,D，如果没被捕获直接执行D然后退出 Test Test Strategy 白盒测试 针对代码执行路径设计测试，要求全覆盖 黑盒测试 只考虑spec 等价类划分 正负，奇偶，整数非整数，具体某格式和非该格式，长度限制，数据上限 考虑边界值 边界值及边界值附近 /* * Testing Strategy * * Partition the inputs as follow * text.length() : 0, 1, &amp;gt;1 * start : 0, 1, 1&amp;lt;start&amp;lt;text.length(), text.length()-1, text.length() * text.length()-start : 0, 1, even&amp;gt;1, odd&amp;gt;1 * * Include ... because ... * */ // cover text.length() = 0 // start = text.length = 0 @Text public void testXXX(){ ... }</summary></entry><entry><title type="html">Software Construction之ADT</title><link href="http://localhost:3798/2019/06/21/Software-Construction-ADT.html" rel="alternate" type="text/html" title="Software Construction之ADT" /><published>2019-06-21T00:00:00+08:00</published><updated>2019-06-21T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/21/Software%20Construction%20ADT</id><content type="html" xml:base="http://localhost:3798/2019/06/21/Software-Construction-ADT.html">&lt;h3 id=&quot;mutable和immutable&quot;&gt;Mutable和Immutable&lt;/h3&gt;
&lt;p&gt;Primitive:int,Integer,String…为Immutable，在
stack中分配内存&lt;br /&gt;
Object:Immutable/Mutable，heap中分配内存
防御式拷贝&lt;/p&gt;

&lt;h3 id=&quot;check&quot;&gt;check&lt;/h3&gt;
&lt;p&gt;静态类型检查：可在编译阶段发现错误，是关于“类型”的检查，不考虑值&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;语法错误&lt;/li&gt;
  &lt;li&gt;类名/函数名错误&lt;/li&gt;
  &lt;li&gt;参数数目错误&lt;/li&gt;
  &lt;li&gt;参数类型错误&lt;/li&gt;
  &lt;li&gt;返回值类型错误
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// b cannot be resolved to a variable&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;---------------&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// The local variable b may not have been initialized&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;动态检查：关于“值”的检查&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;非法的参数值(int=int/0会error,double=int/double(0)等返回Infinity不会error)&lt;/li&gt;
  &lt;li&gt;非法的返回值&lt;/li&gt;
  &lt;li&gt;越界&lt;/li&gt;
  &lt;li&gt;空指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;snapshot-diagram&quot;&gt;Snapshot diagram&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;基本类型的值
&lt;img src=&quot;https://i.postimg.cc/tJKPLmtB/0036.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;对象类型的值
&lt;img src=&quot;https://i.postimg.cc/zGSWc7Lk/0037.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Immutable的值用双线椭圆
&lt;img src=&quot;https://i.postimg.cc/sgR7mq2X/0038.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;值的改变
&lt;img src=&quot;https://i.postimg.cc/ncmqvppg/0039.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;final值使用双线箭头
&lt;img src=&quot;https://i.postimg.cc/3rVg4d52/0040.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;exception&quot;&gt;Exception&lt;/h3&gt;
&lt;p&gt;checked exception:要handle的exception，如：找不到xxx&lt;br /&gt;
unchecked exception:不handle，直接退出的exception，如&lt;code class=&quot;highlighter-rouge&quot;&gt;Null­Pointer­Exception&lt;/code&gt;&lt;br /&gt;
不用handle的是unchecked，用handle的是checked&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/g2PWRnTQ/0041.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
Exception类是checked exception&lt;br /&gt;
RuntimeException和Error类是unchecked exception&lt;/p&gt;
&lt;h3 id=&quot;spec&quot;&gt;Spec&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;spec里不需要解释参数的类型&lt;/li&gt;
  &lt;li&gt;若spec:A&amp;gt;=spec:B，那么满足A的precondition&amp;lt;=B的precondition,且对于满足B的precondition来说，A的postcondition&amp;gt;=B的postcondition。&lt;br /&gt;
也就是更弱的precondition或更强的postcondition，意味着更少的实现方式，和更多的用户使用。&lt;br /&gt;
两个不可比较的spec也可能有交集。&lt;/li&gt;
  &lt;li&gt;好的spec应该是倾向于陈述性，而不是具体的实现。&lt;br /&gt;
好的spec应该既不强也不弱，强会给实现带来负担，弱会给client的使用带来限制。&lt;br /&gt;
好的spec应该是解耦的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;abstract-type&quot;&gt;Abstract type&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;区分Creator和Producer：A的Creater是用非A的参数来构造一个A并返回，A的Producer是用一个A来构造一个A并返回。&lt;/li&gt;
  &lt;li&gt;区分Creator/Producer和Observor：A的Observor是返回一个非A的对象，A的Creator/Producer是返回一个A的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spec和rep&quot;&gt;Spec和Rep&lt;/h3&gt;
&lt;p&gt;Spec包括函数名，包括类名。&lt;br /&gt;
Rep包括field和field的注释。&lt;/p&gt;
&lt;h3 id=&quot;representation-independence&quot;&gt;Representation independence&lt;/h3&gt;
&lt;p&gt;表示独立性：Client不需要考虑ADT中的具体实现。&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">Mutable和Immutable Primitive:int,Integer,String…为Immutable，在 stack中分配内存 Object:Immutable/Mutable，heap中分配内存 防御式拷贝 check 静态类型检查：可在编译阶段发现错误，是关于“类型”的检查，不考虑值 语法错误 类名/函数名错误 参数数目错误 参数类型错误 返回值类型错误 int a = 5; if (a &amp;gt; 10) { int b = 2; } else { int b = 4; } b *= 3; // b cannot be resolved to a variable --------------- int a = 5; int b; if (a &amp;gt; 10) { b = 1; } b *= 3; // The local variable b may not have been initialized 动态检查：关于“值”的检查 非法的参数值(int=int/0会error,double=int/double(0)等返回Infinity不会error) 非法的返回值 越界 空指针 Snapshot diagram 基本类型的值 对象类型的值 Immutable的值用双线椭圆 值的改变 final值使用双线箭头 Exception checked exception:要handle的exception，如：找不到xxx unchecked exception:不handle，直接退出的exception，如Null­Pointer­Exception 不用handle的是unchecked，用handle的是checked Exception类是checked exception RuntimeException和Error类是unchecked exception Spec spec里不需要解释参数的类型 若spec:A&amp;gt;=spec:B，那么满足A的precondition&amp;lt;=B的precondition,且对于满足B的precondition来说，A的postcondition&amp;gt;=B的postcondition。 也就是更弱的precondition或更强的postcondition，意味着更少的实现方式，和更多的用户使用。 两个不可比较的spec也可能有交集。 好的spec应该是倾向于陈述性，而不是具体的实现。 好的spec应该既不强也不弱，强会给实现带来负担，弱会给client的使用带来限制。 好的spec应该是解耦的。 Abstract type 区分Creator和Producer：A的Creater是用非A的参数来构造一个A并返回，A的Producer是用一个A来构造一个A并返回。 区分Creator/Producer和Observor：A的Observor是返回一个非A的对象，A的Creator/Producer是返回一个A的对象。 Spec和Rep Spec包括函数名，包括类名。 Rep包括field和field的注释。 Representation independence 表示独立性：Client不需要考虑ADT中的具体实现。</summary></entry><entry><title type="html">Software Construction之Thread</title><link href="http://localhost:3798/2019/06/20/Software-Construction-Thread.html" rel="alternate" type="text/html" title="Software Construction之Thread" /><published>2019-06-20T00:00:00+08:00</published><updated>2019-06-20T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/20/Software%20Construction%20Thread</id><content type="html" xml:base="http://localhost:3798/2019/06/20/Software-Construction-Thread.html">&lt;h2 id=&quot;java中多线程的状态及转移&quot;&gt;Java中多线程的状态及转移&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/tTwXyz1x/0034.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadstart和threadrun的区别&quot;&gt;Thread.start()和Thread.run()的区别&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Thread.start()只能被调用一次，而Thread.run()可以被调用多次&lt;/li&gt;
  &lt;li&gt;Thread.start()是真正的多线程，在得到cpu的time slice时，开始执行run()方法；而Thread.run()只是一个函数，当Thread.run()被调用时，程序顺序执行Thread.run()的内容，执行结束后才会继续执行后面的内容
    &lt;h2 id=&quot;主动改变线程状态的方法&quot;&gt;主动改变线程状态的方法&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread.sleep()&lt;br /&gt;
注意，Thread.sleep()需要处理InterruptedException异常&lt;/li&gt;
  &lt;li&gt;Thread.interrupt()&lt;br /&gt;
注意，Thread.interrupted()只会在Thread.sleep()时或者使用Thread.interrupted()/Thread.currentThread().isInterrupted()时检测，否则即使外界调用Thread.interrupt()，线程仍然继续执行&lt;br /&gt;
举例来说，下面的代码不会停止，会一直输出”Running”
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Running&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;想要接收到interrupt信号需要下面这种写法&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Running&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;或者&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Running&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;thread-safe&quot;&gt;Thread Safe&lt;/h2&gt;
    &lt;h3 id=&quot;confinement&quot;&gt;Confinement&lt;/h3&gt;
    &lt;p&gt;线程之间不共享mutable数据(避免使用mutable的全局变量)&lt;/p&gt;
    &lt;h3 id=&quot;immutability&quot;&gt;Immutability&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;No mutator methods&lt;/li&gt;
  &lt;li&gt;All fields are private and final&lt;/li&gt;
  &lt;li&gt;No representation exposure&lt;/li&gt;
  &lt;li&gt;No mutation whatsoever of mutable objects in the rep not even beneficent mutation
    &lt;h3 id=&quot;threadsafe-data-types&quot;&gt;Threadsafe Data Types&lt;/h3&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;synchronizedMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;即使在线程安全的ADT上，使用 iterator也是不安全的&lt;/p&gt;
    &lt;h3 id=&quot;lock&quot;&gt;Lock&lt;/h3&gt;
    &lt;p&gt;使用synchronized
使用方法：&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;等价于&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h3 id=&quot;threadsafe-和-race-condition&quot;&gt;&lt;strong&gt;Threadsafe 和 race condition&lt;/strong&gt;&lt;/h3&gt;
    &lt;p&gt;&lt;strong&gt;注意：这是两个没有关系的词&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Threadsafe只保证在多线程的情况下，ADT依然满足ADT的spec&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Threadsafe的ADT依然会发生race condition&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;比如HashSet的Iterator，在多线程下不是ThreadSafe的，因为Iterator的spec要求在使用Iterator时，不能修改HashSet&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;但即便使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedMap&lt;/code&gt;，虽然get(),put()等操作是Threadsafe的，但Iterator仍然不是Threadsafe&lt;/strong&gt;&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;s:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;// not threadsafe, even if lst is a synchronized list wrapper&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;strong&gt;即使使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedMap&lt;/code&gt;，当两个Thread同时调用put()操作，是race condition&lt;/strong&gt;&lt;/p&gt;
    &lt;h2 id=&quot;锁&quot;&gt;锁&lt;/h2&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized (list) { ... }&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;只代表别人不能用list的锁&lt;/strong&gt;&lt;/p&gt;
    &lt;h3 id=&quot;死锁deadlock&quot;&gt;死锁(Deadlock)&lt;/h3&gt;
    &lt;p&gt;如下图所示，当T1进入锁定a，T2进入锁定b后，T1和T2进入死锁&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/kg4hzHJF/0035.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
如何判断死锁？&lt;br /&gt;
两个进程有T1和T2，锁的序列为S1和S2，取S1和S2的任意两个前缀P1和P2(P1∩P2为空)，以及相应的下一位N1和N2。&lt;br /&gt;
若N1$\in$P2且N2$\in$P1则N1和N2死锁。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">Java中多线程的状态及转移 Thread.start()和Thread.run()的区别 Thread.start()只能被调用一次，而Thread.run()可以被调用多次 Thread.start()是真正的多线程，在得到cpu的time slice时，开始执行run()方法；而Thread.run()只是一个函数，当Thread.run()被调用时，程序顺序执行Thread.run()的内容，执行结束后才会继续执行后面的内容 主动改变线程状态的方法 Thread.sleep() 注意，Thread.sleep()需要处理InterruptedException异常 Thread.interrupt() 注意，Thread.interrupted()只会在Thread.sleep()时或者使用Thread.interrupted()/Thread.currentThread().isInterrupted()时检测，否则即使外界调用Thread.interrupt()，线程仍然继续执行 举例来说，下面的代码不会停止，会一直输出”Running” Thread a=new Thread(new Runnable() { @Override public void run() { while(true){ System.out.println(&quot;Running&quot;); } } }); a.start(); a.interrupt(); 想要接收到interrupt信号需要下面这种写法 Thread a=new Thread(new Runnable() { @Override public void run() { while(!Thread.interrupted()){ System.out.println(&quot;Running&quot;); } } }); a.start(); a.interrupt(); 或者 Thread a = new Thread(new Runnable() { @Override public void run() { try { while (true) { System.out.println(&quot;Running&quot;); Thread.sleep(100); } } catch (InterruptedException ie){ } } }); a.start(); a.interrupt(); Thread Safe Confinement 线程之间不共享mutable数据(避免使用mutable的全局变量) Immutability No mutator methods All fields are private and final No representation exposure No mutation whatsoever of mutable objects in the rep not even beneficent mutation Threadsafe Data Types private static Map&amp;lt;Integer,Boolean&amp;gt; cache = Collections.synchronizedMap(new HashMap&amp;lt;&amp;gt;()); 即使在线程安全的ADT上，使用 iterator也是不安全的 Lock 使用synchronized 使用方法： public void foo(){ synchronized(this){ ... } } 等价于 public synchronized void foo(){ ... } Threadsafe 和 race condition 注意：这是两个没有关系的词 Threadsafe只保证在多线程的情况下，ADT依然满足ADT的spec Threadsafe的ADT依然会发生race condition 比如HashSet的Iterator，在多线程下不是ThreadSafe的，因为Iterator的spec要求在使用Iterator时，不能修改HashSet 但即便使用了Collections.synchronizedMap，虽然get(),put()等操作是Threadsafe的，但Iterator仍然不是Threadsafe for (String s: lst) { ... } // not threadsafe, even if lst is a synchronized list wrapper 即使使用了Collections.synchronizedMap，当两个Thread同时调用put()操作，是race condition 锁 synchronized (list) { ... } 只代表别人不能用list的锁 死锁(Deadlock) 如下图所示，当T1进入锁定a，T2进入锁定b后，T1和T2进入死锁 如何判断死锁？ 两个进程有T1和T2，锁的序列为S1和S2，取S1和S2的任意两个前缀P1和P2(P1∩P2为空)，以及相应的下一位N1和N2。 若N1$\in$P2且N2$\in$P1则N1和N2死锁。</summary></entry><entry><title type="html">Monte Carlo Methods for Volumetric Light Transport Simulation</title><link href="http://localhost:3798/2019/05/09/Monte-Carlo-Methods-for-Volumetric-Light-Transport-Simulation.html" rel="alternate" type="text/html" title="Monte Carlo Methods for Volumetric Light Transport Simulation" /><published>2019-05-09T00:00:00+08:00</published><updated>2019-05-09T00:00:00+08:00</updated><id>http://localhost:3798/2019/05/09/Monte%20Carlo%20Methods%20for%20Volumetric%20Light%20Transport%20Simulation</id><content type="html" xml:base="http://localhost:3798/2019/05/09/Monte-Carlo-Methods-for-Volumetric-Light-Transport-Simulation.html">&lt;h2 id=&quot;section-2-optical-properties&quot;&gt;Section 2. Optical Properties&lt;/h2&gt;

&lt;h3 id=&quot;collision-coefficient&quot;&gt;Collision Coefficient&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;density per unit volume: $\rho (m^{-3})$&lt;/li&gt;
  &lt;li&gt;cross sectional area: $\sigma_{s}, \sigma_{a} (m^2)$&lt;/li&gt;
  &lt;li&gt;scattering(absorption) coefficient: $\mu_{s}(\mu_{a})=\sigma_{s}(\sigma_{a}) \cdot \rho (m^{-1})$&lt;/li&gt;
  &lt;li&gt;extinction coefficient: $\mu_{t}=\mu_{s}+\mu_{a}$&lt;/li&gt;
  &lt;li&gt;single-scattering albedo: $\alpha=\frac{\mu_{s}}{\mu_{t}}$&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;phase-function&quot;&gt;Phase Function&lt;/h3&gt;

&lt;p&gt;Examples: Henyey-Greenstein, Rayleigh, Lorenz-Mie.&lt;/p&gt;

&lt;p&gt;For more details in &lt;em&gt;Handbook of Digital Image Synthesis: Scientific Foundations of Rendering&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3-volumetric-rendering-equation&quot;&gt;Section 3. Volumetric Rendering Equation&lt;/h2&gt;

&lt;h3 id=&quot;radiative-transfer-equation-rte&quot;&gt;Radiative Transfer Equation (RTE)&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\omega\cdot\nabla)\cdot L(x,\omega)=-\mu_{t}(x)L(x,\omega)+\mu_{a}(x)L_{e}(x,\omega)+\mu_{s}(x)L_{s}(x,\omega)&lt;/script&gt;

&lt;p&gt;Then, this differential equation can yield&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L(x,\omega)=\int_{0}^{\infty}T(x,y)[\mu_{a}(y)L_{e}(y,\omega)+\mu_{s}(y)L_{s}(y,\omega)]dt&lt;/script&gt;

&lt;p&gt;Here, $y=x-t\cdot\omega$, $T(x,y)=e^{-\int_{x}^{y}\mu_{t}(z)dz}$(Beer Lambert Law)&lt;/p&gt;

&lt;h3 id=&quot;volume-rendering-equation&quot;&gt;Volume Rendering Equation&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L(x,\omega)=\int_{0}^{dist}T(x,y)[\mu_{a}(y)L_{e}(y,\omega)+\mu_{s}(y)L_{s}(y,\omega)]dt+T(x,z)L(z,\omega)&lt;/script&gt;

&lt;p&gt;Here,$z=x-dist\cdot \omega$&lt;/p&gt;

&lt;h3 id=&quot;path-integral-formulation&quot;&gt;Path Integral Formulation&lt;/h3&gt;

&lt;p&gt;$\overline{x_{k}}={x_0,x_1,\dots,x_k}$, the $x_0$ is the point on the sensor&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(\overline{x_{k}})=W(x_0,x_1)G(x_0,x_1)T(x_0,x_1)\cdot L_{e}(x_k\rightarrow x_{k-1})\cdot \prod_{i=1}^{i=k-1}f_{s}(x_{i+1}\rightarrow x_{i}\rightarrow x_{i-1})G(x_{i},x_{i+1})T(x_{i},x_{i+1})&lt;/script&gt;

&lt;p&gt;$W$ is response of the point on the sensor&lt;/p&gt;

&lt;p&gt;$G(x,y)=\frac{D(x,y)\cdot D(y,x)}{\Vert x-y\Vert ^2}$&lt;/p&gt;

&lt;p&gt;$D(x,y)=\begin{cases} \vert n(x)\cdot \omega_{x\rightarrow y}\vert &amp;amp; \text{x is on a surface} \newline 1 &amp;amp; \text{x is in a medium} \end{cases}$&lt;/p&gt;

&lt;p&gt;$f_{x\rightarrow y\rightarrow z}=\begin{cases} f_{r}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is on a surface} \newline \mu_{s}(y)\cdot f_{p}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is in a medium} \end{cases}$&lt;/p&gt;

&lt;p&gt;$L_{e}(x\rightarrow y)=\begin{cases} L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is on a surface} \newline \mu_{a}(x)L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is in a medium}\end{cases}$&lt;/p&gt;

&lt;h2 id=&quot;section-4-distance-sampling&quot;&gt;Section 4. Distance Sampling&lt;/h2&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Computer-Graphics" /><summary type="html">Section 2. Optical Properties Collision Coefficient density per unit volume: $\rho (m^{-3})$ cross sectional area: $\sigma_{s}, \sigma_{a} (m^2)$ scattering(absorption) coefficient: $\mu_{s}(\mu_{a})=\sigma_{s}(\sigma_{a}) \cdot \rho (m^{-1})$ extinction coefficient: $\mu_{t}=\mu_{s}+\mu_{a}$ single-scattering albedo: $\alpha=\frac{\mu_{s}}{\mu_{t}}$ Phase Function Examples: Henyey-Greenstein, Rayleigh, Lorenz-Mie. For more details in Handbook of Digital Image Synthesis: Scientific Foundations of Rendering Section 3. Volumetric Rendering Equation Radiative Transfer Equation (RTE) Then, this differential equation can yield Here, $y=x-t\cdot\omega$, $T(x,y)=e^{-\int_{x}^{y}\mu_{t}(z)dz}$(Beer Lambert Law) Volume Rendering Equation Here,$z=x-dist\cdot \omega$ Path Integral Formulation $\overline{x_{k}}={x_0,x_1,\dots,x_k}$, the $x_0$ is the point on the sensor $W$ is response of the point on the sensor $G(x,y)=\frac{D(x,y)\cdot D(y,x)}{\Vert x-y\Vert ^2}$ $D(x,y)=\begin{cases} \vert n(x)\cdot \omega_{x\rightarrow y}\vert &amp;amp; \text{x is on a surface} \newline 1 &amp;amp; \text{x is in a medium} \end{cases}$ $f_{x\rightarrow y\rightarrow z}=\begin{cases} f_{r}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is on a surface} \newline \mu_{s}(y)\cdot f_{p}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is in a medium} \end{cases}$ $L_{e}(x\rightarrow y)=\begin{cases} L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is on a surface} \newline \mu_{a}(x)L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is in a medium}\end{cases}$ Section 4. Distance Sampling</summary></entry><entry><title type="html">Last Time</title><link href="http://localhost:3798/2019/04/10/Last-Time.html" rel="alternate" type="text/html" title="Last Time" /><published>2019-04-10T00:00:00+08:00</published><updated>2019-04-10T00:00:00+08:00</updated><id>http://localhost:3798/2019/04/10/Last%20Time</id><content type="html" xml:base="http://localhost:3798/2019/04/10/Last-Time.html">&lt;h2 id=&quot;todolist-&quot;&gt;ToDoList :&lt;/h2&gt;
&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1A 250&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1A 500&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;TCO14 Round 1A 1000&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;TCO14 Round 1B 200&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1B 600&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1B 900&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1C 250&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1C 450&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 1C 950&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 2A 250&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 2A 500&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;TCO14 Round 2A 1000&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 2B 350&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;TCO14 Round 2B 500&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;TCO14 Round 2B 900&lt;br /&gt;
杭电3 A Azshara’s deep sea    &lt;br /&gt;
牛客6 F K-ary Heap  &lt;br /&gt;
no 杭电4 D Enveloping Convex&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;timeline&quot;&gt;Timeline&lt;/h2&gt;
&lt;h3 id=&quot;20190902-20190908&quot;&gt;2019/09/02-2019/09/08&lt;/h3&gt;
&lt;h4 id=&quot;2800-3800&quot;&gt;2800-3800&lt;/h4&gt;
&lt;p&gt;JAG 2009 E Symmetry&lt;br /&gt;
2017 SEERC Divide and Conquer&lt;br /&gt;
上海网络赛 Counting Sequences II&lt;br /&gt;
2018 ICPC 北京 G Solving Equations is Easy&lt;/p&gt;

&lt;h4 id=&quot;2500-2700&quot;&gt;2500-2700&lt;/h4&gt;
&lt;p&gt;沈阳网络赛 Special necklace&lt;br /&gt;
沈阳网络赛 Ghh Matin&lt;br /&gt;
沈阳网络赛 Gugugu’s upgrade schemes&lt;/p&gt;
&lt;h4 id=&quot;2100-2400&quot;&gt;2100-2400&lt;/h4&gt;

&lt;h3 id=&quot;20190902-20190908-1&quot;&gt;2019/09/02-2019/09/08&lt;/h3&gt;
&lt;h4 id=&quot;2800-3800-1&quot;&gt;2800-3800&lt;/h4&gt;
&lt;p&gt;ICPC 2018 徐州 D Rikka with Subsequences &lt;br /&gt;
ICPC 2018 徐州 I Rikka with Sorting Networks &lt;br /&gt;
2019 徐州网络赛 F Little M’s attack plan &lt;br /&gt;
JSOI 2018 战争 &lt;br /&gt;
SCOI 2015 小凸想跑步&lt;/p&gt;

&lt;h4 id=&quot;2500-2700-1&quot;&gt;2500-2700&lt;/h4&gt;
&lt;h4 id=&quot;2100-2400-1&quot;&gt;2100-2400&lt;/h4&gt;

&lt;h3 id=&quot;20190812-20190819&quot;&gt;2019/08/12-2019/08/19&lt;/h3&gt;
&lt;h4 id=&quot;2800-3800-2&quot;&gt;2800-3800&lt;/h4&gt;
&lt;p&gt;2018多校9 E Rikka with Rain&lt;br /&gt;
牛客10 G Road Construction&lt;br /&gt;
UVA 1017 World Finals 2002 Merrily, We Roll Along!   &lt;br /&gt;
POJ 1418 Viva Confetti&lt;br /&gt;
POJ 3384 Feng Shui&lt;/p&gt;

&lt;h4 id=&quot;2500-2700-2&quot;&gt;2500-2700&lt;/h4&gt;
&lt;h4 id=&quot;2100-2400-2&quot;&gt;2100-2400&lt;/h4&gt;

&lt;h3 id=&quot;20190805-20190811&quot;&gt;2019/08/05-2019/08/11&lt;/h3&gt;
&lt;h4 id=&quot;2800-3800-3&quot;&gt;2800-3800&lt;/h4&gt;
&lt;p&gt;ICPC 2018 北京 Rikka with Triangles &lt;br /&gt;
ICPC 2018 徐州 Rikka with Illuminations&lt;br /&gt;
SRM 595 Constellation(Hard)&lt;br /&gt;
SRM 573 WolfPack(Hard) &lt;br /&gt;
SRM 750 PurpleSubsequences(Hard)&lt;/p&gt;

&lt;h4 id=&quot;2500-2700-3&quot;&gt;2500-2700&lt;/h4&gt;
&lt;h4 id=&quot;2100-2400-3&quot;&gt;2100-2400&lt;/h4&gt;

&lt;h3 id=&quot;20190729-20190804&quot;&gt;2019/07/29-2019/08/04&lt;/h3&gt;
&lt;h4 id=&quot;2800-3800-4&quot;&gt;2800-3800&lt;/h4&gt;
&lt;p&gt;杭电4 E Good Numbers &lt;br /&gt;
杭电4 F Horse&lt;br /&gt;
牛客5 F maximum clique 1&lt;/p&gt;
&lt;h4 id=&quot;2500-2700-4&quot;&gt;2500-2700&lt;/h4&gt;
&lt;p&gt;杭电4 C Divide the stones&lt;br /&gt;
牛客6 E Androgynos&lt;br /&gt;
牛客5 C generator 2&lt;br /&gt;
牛客5 E independent set 1  &lt;br /&gt;
牛客5 I three points 1&lt;/p&gt;
&lt;h4 id=&quot;2100-2400-4&quot;&gt;2100-2400&lt;/h4&gt;

&lt;h3 id=&quot;20190722-20190728&quot;&gt;2019/07/22-2019/07/28&lt;/h3&gt;

&lt;h4 id=&quot;2800-3800-5&quot;&gt;2800-3800&lt;/h4&gt;
&lt;p&gt;ABC 134 F Permutation Oddness&lt;br /&gt;
SRM 648 Fragile(Hard) &lt;br /&gt;
SRM 633 GCDLCM(Hard)  &lt;br /&gt;
388E Fox and Meteor Shower(3000)&lt;br /&gt;
528E Triangles 3000(3000)&lt;/p&gt;
&lt;h4 id=&quot;2500-2700-5&quot;&gt;2500-2700&lt;/h4&gt;

&lt;h4 id=&quot;2100-2400-5&quot;&gt;2100-2400&lt;/h4&gt;
&lt;p&gt;牛客4 D triples I&lt;/p&gt;

&lt;h3 id=&quot;20190715-20190721&quot;&gt;2019/07/15-2019/07/21&lt;/h3&gt;

&lt;h4 id=&quot;2800-3800-6&quot;&gt;2800-3800&lt;/h4&gt;
&lt;p&gt;SRM 655 BichromeSky(Hard)&lt;br /&gt;
1146H Satanic Panic(2800)&lt;br /&gt;
1142C U2(2800)&lt;/p&gt;
&lt;h4 id=&quot;2500-2700-6&quot;&gt;2500-2700&lt;/h4&gt;
&lt;p&gt;1195F Geometers Anonymous Club(2700)&lt;br /&gt;
1194F Crossword Expert(2500)&lt;/p&gt;
&lt;h4 id=&quot;2100-2400-6&quot;&gt;2100-2400&lt;/h4&gt;
&lt;p&gt;1190D Tokitsukaze and Strange Rectangle(2200)&lt;br /&gt;
1194E Count The Rectangles(2200)&lt;br /&gt;
1188B Count Pairs(2200)&lt;br /&gt;
1195E OpenStreetMap(2100)&lt;/p&gt;

&lt;h2 id=&quot;topcoder&quot;&gt;Topcoder&lt;/h2&gt;

&lt;h3 id=&quot;srm-754&quot;&gt;SRM 754&lt;/h3&gt;
&lt;h4 id=&quot;medium&quot;&gt;Medium&lt;/h4&gt;
&lt;p&gt;题意 : 给定投影等价类数，构造一组点集方案。&lt;br /&gt;
题解 : 两个点有两个等价类，对于一个点集，$n^2$条直线去重后的个数为等价类数。构造两列点即可。&lt;/p&gt;
&lt;h4 id=&quot;hard&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 给定$4$连通块大小和$8$连通块大小，返回构造结果。&lt;br /&gt;
题解 : $8$连通块是由若干$4$连通块组合起来，状压DP一下，DP出一组解。然后按行构造即可。&lt;/p&gt;

&lt;h3 id=&quot;srm-753&quot;&gt;SRM 753&lt;/h3&gt;
&lt;h4 id=&quot;hard-1&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 给定一个序列，区间询问去掉一个数后的最大异或和。&lt;br /&gt;
题解 : 可持久化Trie树，区间异或和在区间的Trie树上异或出最大值。&lt;/p&gt;

&lt;h3 id=&quot;2019-humblefool-cup-prelims&quot;&gt;2019 Humblefool Cup Prelims&lt;/h3&gt;
&lt;h4 id=&quot;hard-2&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 定义相邻的两个质数为只有一个数位不同，且长度相同。询问两个质数可以到达。&lt;br /&gt;
题解 : 质数非常连通，预处理之后会发现，只有$4$个块，$2$个是孤点，还有$1$个是大小为$2$的块，剩下的点全部联通。&lt;/p&gt;

&lt;h3 id=&quot;srm-752&quot;&gt;SRM 752&lt;/h3&gt;
&lt;h4 id=&quot;hard-3&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 有$n$个硬币在桌子上，有$1$个硬币在手里，每次抛硬币，正面的话桌面上加$1$个硬币，手里留$1$个硬币，如果桌上有$2N$个硬币则游戏结束。反面的话，从桌上硬币拿走手里的硬币数个放到手里，如果桌上拿空则游戏结束。输出期望场数。&lt;br /&gt;
题解 : 转移显然有环，但是由于正面的特殊性，定义$f[i]$表示手里$1$个硬币，桌上$i$个硬币的期望场数。转移方程$f[i]=(f[i+1]+1)*0.5+(f[i]+2)*0.5^2+(f[i-2]+3)*0.5^3+\cdots$。可以发现转移有后效性，但是我们可以将$f[i+1]$去除后效性。&lt;/p&gt;

&lt;h3 id=&quot;srm-750&quot;&gt;SRM 750&lt;/h3&gt;
&lt;h4 id=&quot;hard-purplesubsequences&quot;&gt;Hard PurpleSubsequences&lt;/h4&gt;
&lt;p&gt;题意 : 给定一个长度为$n$的序列，询问最长上升子序列长度大于等于$L$的本质不同子序列个数。$n\le 60,x_i\le 20,L\le 6$&lt;br /&gt;
题解 : 本质不同先建出序列自动机，然后在上面大力DP。DP的过程中类似我们直接求解LIS的过程，把保存LIS长度为i的最后一个数字的数组保存在每个节点上。&lt;br /&gt;
$O(n^2S)$&lt;/p&gt;

&lt;h3 id=&quot;srm-655&quot;&gt;SRM 655&lt;/h3&gt;
&lt;h4 id=&quot;hard-4&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : $n$个红点，$m$个蓝点，没有三点共线，第i个红点以$p_i$的概率出现，求红点的凸包包含所有蓝点的概率。$n, m \le 100$&lt;br /&gt;
题解 : 对于包含所有蓝点的要求，等价于包含所有蓝点形成的凸包。对于一个红点，对蓝点构成的凸包做切线，这两条切线是这个红点的覆盖范围。问题就转化为有$n$个区间，每个区间出现的概率为$p_i$，询问全部覆盖的概率，DP一下即可。&lt;br /&gt;
复杂度$O(n^3)$。&lt;/p&gt;

&lt;h3 id=&quot;srm-648&quot;&gt;SRM 648&lt;/h3&gt;
&lt;h4 id=&quot;hard-fragile&quot;&gt;Hard Fragile&lt;/h4&gt;
&lt;p&gt;题意 : 询问有$m$个桥的带标号的$n$个点的图的个数，$n\le 50, 0\le m\le n-1$。&lt;br /&gt;
题解 : 首先，我们可以先求出$n$个点$m$个桥的连通图个数，然后背包求答案即可。&lt;br /&gt;
然后，对于一个桥，断开之后就变为了两个联通图，所以我们考虑dp求出$f[i][j][k]$为$i$个点，$1$号点所在边双大小为$j$，桥的个数为$k$的方案数。&lt;br /&gt;
转移的时候还需要$n$个点的连通图个数，再dp一次求一下。&lt;br /&gt;
没有桥的情况拿任意的减去所有有桥的。&lt;br /&gt;
复杂度$O(n^5)$。&lt;br /&gt;
PS : 做的时候感觉好麻烦，翻了一下别人的，tourist就是dp的，petr打表了，50的数据范围真的是…&lt;/p&gt;

&lt;h3 id=&quot;srm-633&quot;&gt;SRM 633&lt;/h3&gt;
&lt;h4 id=&quot;hard-gcdlcm&quot;&gt;Hard GCDLCM&lt;/h4&gt;
&lt;p&gt;题意 : 给定四个数组$A,B,C,D$，构造一个数组$x$使得，当$D[i]=0$时，$C[i]=Gcd(x[A[i]],x[B[i]])$，否则$C[i]=Lcm(x[A[i]],x[B[i]])$。&lt;br /&gt;
$n\le 200, C[i]\le 10^9$ &lt;br /&gt;
题解 : 这个感觉还不太难。由于$gcd=\Pi p_i^{min(cnt_a,cnt_b)}$，$lcm=\Pi p_i^{max(cnt_a,cnt_b)}$，那么对于$C[i]$，唯一分解得到幂次后，得到了$x[a]$和$x[b]$对于每个质因子的要求，记$x[i]$对质因子$p$的幂次为$cntX[i][p]$，拿gcd举例就是，$min(cntX[a][p],cntX[b][p])=cntD[i][p]$，可以拆成$cntX[a][p]=cntD[i][p]$且$cntX[b][p]\ge cntD[i][p]$或$cntX[a][p]\ge cntD[i][p]$且$cntX[b][p]=cntD[i][p]$。&lt;br /&gt;
2-sat判一下即可。&lt;br /&gt;
PS : 好久没写2-sat了，写完翻题解的时候翻到了姚老板的blog。&lt;/p&gt;

&lt;h3 id=&quot;srm-595&quot;&gt;SRM 595&lt;/h3&gt;
&lt;h4 id=&quot;hard-constellation&quot;&gt;Hard Constellation&lt;/h4&gt;
&lt;p&gt;题意 : 给定$n$个点，以及他们出现的概率，询问构成凸包的期望面积。$n\le 50$&lt;br /&gt;
题解 : 考虑一个构成凸包内的点，他们出现不出现对于该凸包面积的概率不影响，那么只要考虑在边界的点即可。那么可以想到求凸包面积的方法，是每次求$OA_{i}A_{i+1}$的有向面积。所以枚举两个点，假设他们是凸包上的一条边，即某一侧没有任何点，计算概率。正反各求一次即可。&lt;br /&gt;
$O(n^3)$&lt;/p&gt;

&lt;h3 id=&quot;srm-573&quot;&gt;SRM 573&lt;/h3&gt;
&lt;h4 id=&quot;hard-wolfpack&quot;&gt;Hard WolfPack&lt;/h4&gt;
&lt;p&gt;题意 : 给定$n$个点，每秒每个点可以往上下左右移动一步，询问$m$秒后走到同一个点的方案数。$n\le 50,m\le 10^5$&lt;br /&gt;
题解 : 对于一个点，每次可以$x+1/-1$，$y$不变，或者$y+1/-1$，$x$不变。这里$x$和$y$的变化是相关的，会互相影响，为了消除这种影响可以很自然想到欧几里得距离转切比雪夫距离。&lt;br /&gt;
那么我们将其变换后，每次移动变为$x+1/-1$，$y+1/-1$，这样两维就独立了。然后考虑移动到一个点的方案数，问题就是$n$个数轴上的点，每次左右走，询问$m$秒后走到同一位置的方案数。&lt;br /&gt;
随便取一个点，枚举$+1$的个数，然后计算其他点走到这个点的方案数。$x$和$y$分开求完乘起来即可。&lt;br /&gt;
$O(n^2m)$&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-1b&quot;&gt;TCO 2014 Round 1B&lt;/h3&gt;
&lt;h4 id=&quot;medium-wolvesandsheep&quot;&gt;Medium WolvesAndSheep&lt;/h4&gt;
&lt;p&gt;贪心反例 : &lt;br /&gt;
x[]&lt;br /&gt;
[]v&lt;br /&gt;
纯贪心（按行和列分别做一次），不会分割，所以x还是能到达v。&lt;/p&gt;

&lt;h4 id=&quot;hard-eagleinzoo&quot;&gt;Hard EagleInZoo&lt;/h4&gt;
&lt;p&gt;题意 : 给定一棵树，从根节点放入动物，如果这个节点已经有动物了，就等概率的选择子节点往下走，重复过程直到有空节点或离开树，一旦离开树，这次的过程停止。询问放入$m$个动物，最后一只留在树上的概率。  &lt;br /&gt;
题解 : 关键 : 设计状态转移时，要让转移的方案不相交。&lt;br /&gt;
$dp[i][j]$表示以$i$为根的子树，放入$j$个动物，最后一只能够留在树上的概率。&lt;br /&gt;
转移的时候考虑最后一个动物留在哪个子树，这样使得转移的方案不相交。&lt;br /&gt;
假设以$i$为根的子树放入$j$个动物，$i$的子节点数为$c$，枚举进入某个个子树$ch$的动物数$k$，那么概率为${\frac{1}{c}}^{k}*(1-\frac{1}{c})^{j-1-k}*C_{j-2}^{k-1}$
不管进入别的$ch$的情况是怎么样，所以概率是$1-\frac{1}{c}$&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-2a&quot;&gt;TCO 2014 Round 2A&lt;/h3&gt;
&lt;h4 id=&quot;easy-sixteenbricks&quot;&gt;Easy SixteenBricks&lt;/h4&gt;
&lt;p&gt;题意 : 给定16块$1*1*x[i]$砖，放在$4*4$的格子里，使得可以看见的面积最大。&lt;br /&gt;
题解 : 关键 : 首先要大小交替摆放，然后降维分析。&lt;br /&gt;
$a&amp;gt;b&amp;gt;c&amp;gt;d$，考虑一维情况$adbc$比$acbd$更优，因为两个的面积分别是$2a+2b-2d$和$2a+2b-2c$，然后放在二维即可。&lt;/p&gt;

&lt;h4 id=&quot;medium-narrowpassage&quot;&gt;Medium NarrowPassage&lt;/h4&gt;
&lt;p&gt;题意 : 在$0$到$l$的走廊里，给定每个物品$n\le 50$的初始位置和目标位置，要改变物品的顺序，必须这些物品在最左端或最右端，询问最小移动步数。&lt;br /&gt;
题解 : 关键 : 最优移动的方案。&lt;br /&gt;
首先一种情况是，按最开始的位置分成三段，左边一段全部移到最左边，右边一段全部移到最右边，中间一段自行调整。&lt;br /&gt;
这种情况的要求是，中间段不能交叉，左边和右边那段的目标位置不能跨越中间那段。&lt;br /&gt;
另一种方案是&lt;img src=&quot;http://7xs2ho.com1.z0.glb.clouddn.com/0013.png&quot; alt=&quot;&quot; /&gt;
这类情况的最优方案是，按照起点排序，左边到左端点，右边到右端点，然后按终点排序，枚举边界，右边点的到右端点。&lt;/p&gt;

&lt;h4 id=&quot;hard-treepuzzle&quot;&gt;Hard TreePuzzle&lt;/h4&gt;
&lt;p&gt;题意 : 给定一棵树$(n\le 500)$，给定每个点有无黑点，根节点放一个红点，询问哪些点能被红点到达。&lt;br /&gt;
题解 : 关键 : 分类讨论啊。&lt;br /&gt;
首先，你现在红点在$x$，黑点分布为$f[x]$，$y$为$x$的一个子节点，判断$y$是否可达。&lt;br /&gt;
1.若$y$的子树中空节点数大于等于$1$，则可达。&lt;br /&gt;
2.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数为$0$，即$x$的子树中无空节点，则不可达。&lt;br /&gt;
3.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数大于等于$2$，则可达。&lt;br /&gt;
4.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数等于$1$，记该节点为$z$，其子树中空节点数为$cnt$。&lt;br /&gt;
找到$z$的子树中离$z$最近的，且度数大于等于$3$的节点$z’$，若$cnt\ge z$到$z’$的节点数+$2$，则可到达，否则不可到达。&lt;/p&gt;

&lt;h2 id=&quot;atcoder&quot;&gt;Atcoder&lt;/h2&gt;
&lt;h3 id=&quot;abc-134&quot;&gt;ABC 134&lt;/h3&gt;

&lt;h4 id=&quot;f-permutation-oddness&quot;&gt;F Permutation Oddness&lt;/h4&gt;
&lt;p&gt;题意 : 对于一个长度为$n$的排列$P$，它的权值为$\sum_{i=1}^{n}|P_i-i|$。现在询问长度为$n$，权值为$m$的排列数。$n\le 50$。&lt;br /&gt;
题解 : 首先把这个权值转换一下。这个权值的构成可以看做是两个$1$-$n$顺序排列的匹配，权值为匹配两点的距离差，再转换一下可以看做在$i$和$i+1$($1\le i\le n-1$)中间画一条横线和匹配的线的交点个数。如图:&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/Y9r4QzZB/0061.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
现在假设我们用左侧的点去匹配右侧的点，每次将左侧的点$i$和比它小的点匹配，和比它大的点匹配由另一侧的点来决定。由另一侧点来决定的点暂且视为闲置点。&lt;br /&gt;
假设我们现在匹配完前$i$位了，有$j$个闲置点(左右两侧各$j$个)，那么与$i$和$i+1$中间的直线相交的点的个数为$j$个。&lt;br /&gt;
根据这个我们就可以DP了。&lt;br /&gt;
$f[i][j][k]$表示前$i$位中有$j$位没有匹配，权值和为$k$的方案数。&lt;br /&gt;
$O(1)$转移，复杂度$O(n^4)$&lt;br /&gt;
PS : 这题放在ABC很大原因是OEIS能直接找到所有答案的表。所有日文题解都标了”箱根DP”，get不到这个点，但可能在日本已经人尽皆知了吧。&lt;br /&gt;
PPS : 有兴趣可以看看这个 https://arxiv.org/pdf/1202.4765.pdf&lt;/p&gt;

&lt;h3 id=&quot;arc-88&quot;&gt;ARC 88&lt;/h3&gt;

&lt;h4 id=&quot;d-wide-flip&quot;&gt;D Wide Flip&lt;/h4&gt;
&lt;p&gt;题意 : 给定一个长度为$n$的$01$序列，可以翻转一段连续的长度大于$k$的区间，询问最大的$k$。&lt;br /&gt;
题解 : 关键 : 假设我们选定了一个$k$，我们能单独修改某些单独位置。&lt;br /&gt;
修改第$i\ge k+1$位，可以通过修改$[1,i-1]$和$[1,i]$。&lt;br /&gt;
修改第$i\le n-k$位，可以通过修改$[i,n]$和$[i+1,n]$。&lt;br /&gt;
到了第$i$和$i+1$位为$01/10$时，我们要修改第$i$和$i+1$位都能达到我们的目的，所以取一个更大的$k$。&lt;br /&gt;
$0110010010$&lt;br /&gt;
$1\ \ 3\ \ 56\ \ 89\ \ $  &lt;br /&gt;
$9\ \ 7\ \ 54\ \ 21\ \ $  &lt;br /&gt;
可以观察上图，取$\lceil\frac{n}{2}\rceil$一定可以实现目的，因为可以随意修改左右两侧的值，实际上我们要去找的，最靠近中心的01交替的位置，以这个位置对称过去的两侧都可以随意修改，而剩下来中间的部分不用修改。&lt;/p&gt;
&lt;h4 id=&quot;e-papple-sort&quot;&gt;E Papple Sort&lt;/h4&gt;
&lt;p&gt;题意 : 给定一个字符串，询问通过交换相邻字符，最少几次能变为回文串。  &lt;br /&gt;
题解 : 关键 : &lt;br /&gt;
1.a…a…a…a，第2个a一定不会越过第3个a，也就是说相同字母的相对位置不变。&lt;br /&gt;
2.交换相邻字符我们想到 : 1)可以转化为任意两个位置的交换2)统计答案为求目标位置的逆序对数。&lt;br /&gt;
现在转化为求目标位置，回文的话可以看成是一层一层的，结合第一点我们可以确定第1个a一定和最后一个a是一个回文对，然后我们考虑两对的情况。&lt;br /&gt;
a..a.b…b&lt;br /&gt;
a..b.a…b&lt;br /&gt;
a..b.b…a&lt;br /&gt;
分为上面三种，其中第三种显然最终a在b外面，第一种一定会先变成第二种。&lt;br /&gt;
而第二种,首先我们假设中间的b和a关于中心对称了，因为不对称要整体平移对于ab谁在外面无影响，然后a在外面我们要右侧a移到右侧b外面，b在外面我们要左侧b移到左侧a外面，因为要对称这两个的操作数是相同的。&lt;br /&gt;
所以根据上面三种情况，我们从左向右扫标记每对最终的位置，求一个逆序对即可。&lt;/p&gt;

&lt;h3 id=&quot;arc-89&quot;&gt;ARC 89&lt;/h3&gt;
&lt;h4 id=&quot;d-checker&quot;&gt;D Checker&lt;/h4&gt;
&lt;p&gt;题解 : 关键 : 把每个位置的横纵坐标对$2k$取模。&lt;br /&gt;
做二维前缀和即可。&lt;/p&gt;

&lt;h3 id=&quot;arc-90&quot;&gt;ARC 90&lt;/h3&gt;
&lt;h4 id=&quot;e-avoiding-collision&quot;&gt;E Avoiding Collision&lt;/h4&gt;
&lt;p&gt;题意 : 给定一张无向图，给定两个点$s$和$t$，两个人分别从$s$和$t$出发，并且都沿着最短路走到$t$和$s$，询问两个人不相遇的方案数。  &lt;br /&gt;
题解 : 核心是容斥来求，$ans=$最短路对数-到达同一个点的最短路对数-到达同一条边的最短路对数。&lt;br /&gt;
先分别求出$s$和$t$到每个点的距离$dis_{1/2}[i]$和最短路方案数$num_{1/2}[i]$，最短路对数为$num_{1}[t]^2$，枚举点，若能作为最短路上的点且两人到达时间相同则计入，枚举边，若能作为最短路上的边且两人在边上能够相遇则计入。&lt;/p&gt;

&lt;h4 id=&quot;f-number-of-digits&quot;&gt;F Number of Digits&lt;/h4&gt;
&lt;p&gt;题意 : 定义$f(a)$为$a$在十进制中的位数，给定$S(S\le 10^8)$，询问有多少对$l,r$满足，$\sum_{i=l}^{r}f(i)=S$。  &lt;br /&gt;
题解 : 首先想到$\text{two-point}$，但是$l,r$的范围很大不适用，但但是我们注意到一个关键的性质，当$l\ge10^7$时，因为$f(i)\ge8,i\in[l,r]$，$l$到$r$的距离小于等于$\frac{S}{8}$，所以会得到$f(r)\le f(l)+1$。我们分情况来看一看。&lt;br /&gt;
$1.f(l)=f(r)$，此时要求$f(l)|S$，方案数为$9*10^{f(l)-1}-\frac{S}{f(l)}+1$。&lt;br /&gt;
$2.f(l)+1=f(r)$，令$t=r-l+1$，$f(l)=\text{len}$，$f(r)=\text{len}+1$，$l$到跨越的距离为$x$，跨越到$r$的距离为$y$，得到等式$S=\text{len}*t+y$，枚举$t$，则$y=S\%t$，$x=t-S\%t$，若$x，y$都大于$0$则计入答案&lt;/p&gt;

&lt;h2 id=&quot;codeforces&quot;&gt;Codeforces&lt;/h2&gt;

&lt;h3 id=&quot;codeforces-round-574&quot;&gt;Codeforces Round #574&lt;/h3&gt;

&lt;h4 id=&quot;1195f-geometers-anonymous-club&quot;&gt;1195F Geometers Anonymous Club&lt;/h4&gt;
&lt;p&gt;题意 : 给定$n$个凸包，有$m$次询问，查询在$[l_i,r_i]$中的凸包的闵可夫斯基和的点集大小。  &lt;br /&gt;
题解 : 回想一下合并两个凸包求闵科夫斯基和的过程，会发现相同斜率的线段只用一次，所以问题转化为求区间中颜色个数，离线树状数组即可。&lt;/p&gt;

&lt;h4 id=&quot;1195e-openstreetmap&quot;&gt;1195E OpenStreetMap&lt;/h4&gt;
&lt;p&gt;题意 : 询问在$n\cdot m$的矩阵中，所有$a\cdot b$的子矩阵的最小值的和。$n,m,a,b\le 3000$。&lt;br /&gt;
题解 : 先单调栈求一遍每个点横着往左长度为$a$的最小值，再用这个最小值为权值纵向求一个长度为$b$的，最后全加起来即可。$O(nm)$。&lt;/p&gt;

&lt;h3 id=&quot;educational-codeforces-round-68&quot;&gt;Educational Codeforces Round 68&lt;/h3&gt;

&lt;h4 id=&quot;1194f-crossword-expert&quot;&gt;1194F Crossword Expert&lt;/h4&gt;
&lt;p&gt;题意 : 有$n$个任务，第$i$个任务的完成时间为$t_i$，Bob完成每个任务的时间等概率地为$t_i$或$t_i+1$。现在Bob按顺序完成任务，询问在$m$的时间里，期望完成多少任务。$n\le 2\cdot 10^5, 1\le t_i\le 10^9, m\le 2\cdot 10^{14}$。   &lt;br /&gt;
题解 : 对于第$i$个任务，完成它的概率为$\frac{\sum_{j=0}^{m-sum[i]}C_{i}^{j}}{2^i}$。&lt;br /&gt;
对于$\sum_{j=0}^{a}C_{i}^{j}$转移到$\sum_{j=0}^{a}C_{i+1}^{j}$，可以使用$\sum_{j=0}^{a}C_{i+1}^{j}=2\cdot\sum_{j=0}^{a}C_{i}^{j}-C_{i}^{a}$来实现。&lt;br /&gt;
且由于$m-sum[i]$是下降的，所以可以只用求$O(n)$个组合数即可。&lt;/p&gt;

&lt;h4 id=&quot;1194e-count-the-rectangles&quot;&gt;1194E Count The Rectangles&lt;/h4&gt;
&lt;p&gt;题意 : 给定$n$条平行于x轴 或y轴的线段，求一共能围成多少个不同的矩形。$n\le 5000$。&lt;br /&gt;
题解 : 把$x$轴平行的线按$y$排序，将$y$轴平行的线拆成两个点(入点和出点)，并按$y$轴排序。&lt;br /&gt;
枚举一条$y$轴平行的线，将所有$y$值小于它的点的$x$值加入或删除(入点和出点)，然后按$y$值遍历大于这条平行于$x$轴的线，将$x$值插入和删除，每次查询在这两条平行于$x$轴的线中间合法的$x$值数量即可。$O(n^2\log{n})$。&lt;/p&gt;

&lt;h3 id=&quot;codeforces-round-573&quot;&gt;Codeforces Round #573&lt;/h3&gt;
&lt;h4 id=&quot;1190d-tokitsukaze-and-strange-rectangle&quot;&gt;1190D Tokitsukaze and Strange Rectangle&lt;/h4&gt;
&lt;p&gt;题意 : 给定$n$个点，每次使用一个凹字形的框框出一个点集，询问本质不同的点集个数。$n\le 2\cdot 10^5$。&lt;br /&gt;
题解 : 先把所有点按$y$轴排序，从大到小，每层统计新加入的点与原来的点形成的贡献，每层结束再把新点加进去。离散化和树状数组处理统计贡献即可。&lt;/p&gt;

&lt;h3 id=&quot;codeforces-round-572&quot;&gt;Codeforces Round #572&lt;/h3&gt;
&lt;h4 id=&quot;1188b-count-pairs&quot;&gt;1188B Count Pairs&lt;/h4&gt;
&lt;p&gt;题意 : 给定$n$个值$x_i$，询问有多少对在模$p$意义下满足$(x_i-x_j)\cdot(x_i^2+x_j^2)=k$。$n\le 3\cdot 10^5$&lt;br /&gt;
题解 : 上面的式子乘$x_i+x_j$变为$x_i^4-x_j^4=k(x_i-x_j)$，移项得到$x_i^4-x_i\cdot k=x_j^4-x_j\cdot k$。map处理一下即可。&lt;br /&gt;
$O(n\log{n})$&lt;/p&gt;

&lt;h3 id=&quot;forethought-future-cup---elimination-round&quot;&gt;Forethought Future Cup - Elimination Round&lt;/h3&gt;
&lt;h4 id=&quot;1146h-satanic-panic&quot;&gt;1146H Satanic Panic&lt;/h4&gt;
&lt;p&gt;题意 : 给定平面上$n$个点，询问形成的五角星数量。$n\le 300$&lt;br /&gt;
题解 : 这题有个DP做法，我这里写个组合的。&lt;br /&gt;
首先是$C_{n}^{5}$，考虑减掉不合法的情况。&lt;br /&gt;
形成合法五角星的5个点，肯定是每个点都在这5个点形成的凸包定点上。&lt;br /&gt;
所以，可以分为两种情况：三角形中有两个点，四边形里有一个点。 &lt;br /&gt;
第一种情况，枚举一个三角形，内部拿两个即可。&lt;br /&gt;
第二种情况，枚举一个三角形，在内部拿一个点，外部再拿一个点即可。&lt;br /&gt;
可以使用bitset的与和count来求三角形内点的个数。&lt;br /&gt;
$O(n^3)$&lt;/p&gt;

&lt;h3 id=&quot;codeforces-round-549&quot;&gt;Codeforces Round #549&lt;/h3&gt;
&lt;h4 id=&quot;1142c-u2&quot;&gt;1142C U2&lt;/h4&gt;
&lt;p&gt;题解 : 给定$n$个点，任意两个$x$值不同的点可以求出一个满足$x^2+bx+c=y$的抛物线。询问没有任何点严格在抛物线上方的抛物线个数。$n\le 10^5$。  &lt;br /&gt;
题意 : 对于一个点$(x_i,y_i)$和他所在的抛物线$x^2+b_ix+c_i=y$，要求满足不存在$y’&amp;gt;x’^2+bx’+c$，这个点所在的抛物线可以表示为$bx_i+c=y_i-x_i^2$，$x_i,y_i$已知，而$b,c$未知，可以将$b,c$看做未知数，每个点转化为$(x_i,y_i-x_i^2)$后可以表示为这条直线上的点，那么任意两个转化后的点的连线就是这条直线。&lt;br /&gt;
按照抛物线的要求，要求这条直线上面没有点，即求上凸包。&lt;br /&gt;
注意$x$轴值相同的点不算上凸包的点。  &lt;br /&gt;
$O(n\log{n})$&lt;/p&gt;

&lt;h3 id=&quot;codeforces-round-296&quot;&gt;Codeforces Round #296&lt;/h3&gt;
&lt;h4 id=&quot;528e-triangles-3000&quot;&gt;528E Triangles 3000&lt;/h4&gt;
&lt;p&gt;题意 : $n$条直线，等概率挑选$3$条，求围成三角形面积的期望。$n\le 3000$&lt;br /&gt;
题解 : 考虑怎么求构成的所有三角形的面积。&lt;br /&gt;
对于三角形的三个顶点逆时针为$A,B,C$，面积可以写为$(OA\times OB+OB\times OC+OC \times OA)/2$，同时这三个点都是交点，那么也就可以转化为，枚举一条直线，直线上的所有交点做叉积即可。&lt;br /&gt;
然后对于$OA\times OB+OA\times OC=OA\times(OB+OC)$，极角排序保证逆序，前缀和来维护即可。&lt;/p&gt;

&lt;h3 id=&quot;codeforces-round-228&quot;&gt;Codeforces Round #228&lt;/h3&gt;
&lt;h4 id=&quot;388e-fox-and-meteor-shower&quot;&gt;388E Fox and Meteor Shower&lt;/h4&gt;
&lt;p&gt;题意 : 给出$n$颗流星在$t1$秒和$t2$秒的位置，询问能找到最多多少颗流星，使得两两相交。$n\le 1000$&lt;br /&gt;
题解 : 做的时候没感觉到居然是个讨论题。首先可以看做是个三维直线，那么两两相交的集合就是 :  直线交于同一点或者同一平面且不平行 &lt;br /&gt;
存到Map里，注意细节。&lt;/p&gt;

&lt;h3 id=&quot;educational-codeforces-round-63&quot;&gt;Educational Codeforces Round 63&lt;/h3&gt;
&lt;h4 id=&quot;f-delivery-oligopoly&quot;&gt;F Delivery Oligopoly&lt;/h4&gt;
&lt;p&gt;题意 : 给一张$n(n\le 15)$个点，$m$条边的双连通图。询问删除最多的边使得新图为双连通图的方案。&lt;br /&gt;
题解 : 对于一个双连通图，双连通块的构造方法是一个双连通块加上一条链/一个点。那么我们枚举双连通块点集$s$，枚举一个端点为$i,j$且点集为$t$的链，使得$i,j$分别与$s$内两点相连。&lt;br /&gt;
预处理出$i$到点集$s(i\not\in s)$的最大/次大距离，预处理出点集为$s$，左右端点为$i$和$j$的链的最小花费。转移记录方案。 &lt;br /&gt;
复杂度$O(3^n\cdot n^2)$。&lt;/p&gt;

&lt;h2 id=&quot;多校&quot;&gt;多校&lt;/h2&gt;
&lt;h3 id=&quot;杭电4&quot;&gt;杭电4&lt;/h3&gt;
&lt;h4 id=&quot;c-divide-the-stones&quot;&gt;C Divide the stones&lt;/h4&gt;
&lt;p&gt;题意 : 给定重量为$1$-$n$的石头，要求分成重量相等，数量相同的$m$组。$n\le 100000,\sum n\le 500000,m|n$&lt;br /&gt;
题解 : 每堆石子$\frac{n}{m}$个，重量为$\frac{n(1+n)}{2m}$。&lt;br /&gt;
分情况讨论，如果$2m|n$，那么两头取即可。否则，除去等于1的情况，$\frac{n}{m}$可以写成$3+a$且$2|a$的形式。这时先构造一个将$1$-$3m$放入$m$组，每组$3$个，再把剩下的放进去即可。&lt;/p&gt;
&lt;h4 id=&quot;d-enveloping-convex&quot;&gt;D Enveloping Convex&lt;/h4&gt;

&lt;h4 id=&quot;e-good-numbers&quot;&gt;E Good Numbers&lt;/h4&gt;
&lt;p&gt;题意 : 定义一个数是好的，为$8$进制下每个数码出现次数是$3$的倍数，且该数为$p$的倍数。询问八进制下长度为$n$的好的数有多少。$n\le10^{18},p&amp;lt;8$&lt;br /&gt;
题解 : $f[i][j][k]$表示长度为$i$，每个数码出现次数模$3$的次数，在模$p$下的余数$k$。&lt;br /&gt;
BM+打表&lt;/p&gt;
&lt;h4 id=&quot;f-horse&quot;&gt;F Horse&lt;/h4&gt;
&lt;p&gt;题意 : 初始能量为$0$，现在要越过$n$棵树，高度为$h_i$，越过一棵树能量减少$h_i$，得到收益为当前能量值。&lt;br /&gt;
在越过树前，可以把树吃掉，树的高度变为$0$。&lt;br /&gt;
在越过树后，可以休息，恢复能量值为吃掉的所有树的高度和。&lt;br /&gt;
最多$m$次休息，$t$次吃树，询问最大收益值。&lt;br /&gt;
$n\le10000,m,t\le50,h_i\le10000$&lt;br /&gt;
题解 : 可以发现，得分只在跨越树，休息时能量重置。&lt;br /&gt;
现在，我们考虑得分是怎么构成的。对于第$i$棵树，它的得分为 : 上一次休息前吃的树高和$-$上次休息后没吃的树高和$=$上一次休息前吃的树高和$-($上次休息后的树高和$-$上次休息后吃掉的树高和$)=$前$i$棵树中吃掉的树高和$-$上次休息后到$i$的树高和。&lt;br /&gt;
这两部分就可以分开计算了。&lt;br /&gt;
第一部分，是选择$t$个$h_i$使得$\sum{h_i*(n-i+1)}$最大。&lt;br /&gt;
第二部分，是将序列最多分为$m+1$段，使得每段的权值和最小，区间$l,r$的权值为$\sum_{i=l}^{r}h_i\cdot(r-i+1)$。&lt;br /&gt;
第一个直接做，第二个是决策单调的。&lt;/p&gt;

&lt;h3 id=&quot;牛客6&quot;&gt;牛客6&lt;/h3&gt;
&lt;h4 id=&quot;e-androgynos&quot;&gt;E Androgynos&lt;/h4&gt;
&lt;p&gt;题意 : 构造点数为$n$的自补图。&lt;br /&gt;
题解 : 当$n=4m$或$4m+1$时有解。&lt;br /&gt;
$n=4m$时，将$n$个点等距放在一个圆上，从$1$开始标号，奇数点每次向接下来的$[1,m]$点连边。偶数点向后面的$[m+1,2m]$点连边。映射为每个点标号后移一位。&lt;br /&gt;
$n=4m+1$时，在$n-1=4m$的连边中，偶数点度数比奇数点度数小$1$，将$n$与偶数点连边即可，$n$映射不动。&lt;/p&gt;

&lt;h4 id=&quot;f-k-ary-heap&quot;&gt;F K-ary Heap&lt;/h4&gt;
&lt;p&gt;题意 : &lt;br /&gt;
题解 :&lt;/p&gt;

&lt;h3 id=&quot;牛客5&quot;&gt;牛客5&lt;/h3&gt;
&lt;h4 id=&quot;c-generator-2&quot;&gt;C generator 2&lt;/h4&gt;
&lt;p&gt;题意 : $f_i=a\cdot f_{i-1}+b\cdot f_{i-2}$，求$f_n$。$n\le 10^{10^{6}}$&lt;br /&gt;
题解 : 10进制快速幂。复杂度$O(4\log{n})$&lt;/p&gt;

&lt;h4 id=&quot;e-independent-set-1&quot;&gt;E independent set 1&lt;/h4&gt;
&lt;p&gt;题意 : 给定一个$n$个点$m$条边的图，询问所有子图的最大独立集之和。$n\le26$&lt;br /&gt;
题解 : 对于一个点集$s$，最大独立集的转移分为，去掉一位和去掉一位的相邻点。 &lt;br /&gt;
这一位每次选择末位即可包含全部情况。&lt;br /&gt;
复杂度$O(2^n)$&lt;/p&gt;
&lt;h4 id=&quot;f-maximum-clique-1&quot;&gt;F maximum clique 1&lt;/h4&gt;
&lt;p&gt;题意 : 给定$n$个正整数$x_i$，选出一个集合$S$，满足任意两个数二进制下至少两位不同，询问最大$|S|$。$n\le 5000,x_i\le 10^9$&lt;br /&gt;
题解 : 按题意建图是求最大团，最大团和最大独立集是互补的，所以把条件反过来建立补图，即任意两个数二进制下最多一位不同，由于是集合任意两数不同，所以是任意两数二进制下只有一位不同。&lt;br /&gt;
证明该图是二分图，等价于证明没有奇环。考虑一个数$a$所在的环为奇环，该环上的点$x$与$a$的不同位数记为$f(x)$。$a$邻接的两个环上的点$f(x)$都为$1$，每次走一步可以使得$f(x)$加一或减一，且$f(x)$永远不为$0$，所以环长不为奇数，所以是二分图。按1的个数的奇偶也很好证。  &lt;br /&gt;
求二分图最大独立集即可。 &lt;br /&gt;
每个点有一位不同的点最多$30$个，所以边数为$30n$，复杂度$O(30n^2)$&lt;br /&gt;
输出方案时，输出左侧未匹配点和右侧匹配点。做完二分图匹配后再将所有左侧未匹配点dfs一次，右侧没有被遍历到的点就是合法点。&lt;/p&gt;
&lt;h4 id=&quot;i-three-points-1&quot;&gt;I three points 1&lt;/h4&gt;
&lt;p&gt;题意 : 给定三角形边长，将其放入给定的矩形中，输出一组解。  &lt;br /&gt;
题解 : 别写什么swap了，排列就完事了。&lt;/p&gt;

&lt;h3 id=&quot;牛客-4&quot;&gt;牛客 4&lt;/h3&gt;
&lt;h4 id=&quot;d-triples-i&quot;&gt;D triples I&lt;/h4&gt;
&lt;p&gt;题意 : 询问$n$由最少几个三的倍数或起来得到，输出方案。&lt;br /&gt;
题解 : 题目保证输入都有解，那么如果不是三的倍数最少就是2个数。&lt;br /&gt;
$f[i][j][k]$为前$i$位，第一个数模3的为$j$，第二个数模3的为$k$的解。&lt;br /&gt;
DP比直接做会多个10的倍数。&lt;/p&gt;

&lt;h2 id=&quot;regional&quot;&gt;Regional&lt;/h2&gt;

&lt;h3 id=&quot;icpc-2018-北京-rikka-with-triangles&quot;&gt;ICPC 2018 北京 Rikka with Triangles&lt;/h3&gt;
&lt;p&gt;题意 : 给定$n$个点，询问锐角三角形个数和总面积。$n\le2000$，坐标范围$\le10^{18}$  &lt;br /&gt;
题解 : 首先，锐角三角形不好判断，为什么？比较一下三种三角形，锐角三角形三个角都是锐角，直角三角形和钝角三角形只有一个角是非锐角，所以我们考虑反着求。&lt;br /&gt;
首先，求钝角三角形个数和直角三角形个数。枚举一个点求以这个点为钝角/直角，然后极角排序，满足为大于/等于90度且小于180度的点可以双指针来统计。$O(n^2logn)$ &lt;br /&gt;
其中，$C_{n}^{3}$中会包括三点共线的情况，也要统计。枚举一个点，极角排序，统计$[0,\pi)$的三点共线。$O(n^2logn)$&lt;br /&gt;
面积还是考虑求钝角和直角三角形的面积。和CodeForces 528E Triangles 3000的思路一样，钝角和直角，极角排序，双指针，前缀和优化。总面积和就是528E。$O(n^2logn)$&lt;br /&gt;
这里面极角排序用象限和叉积，使用全整数，__int128。&lt;/p&gt;
&lt;h3 id=&quot;icpc-2018-徐州-d-rikka-with-subsequences&quot;&gt;ICPC 2018 徐州 D Rikka with Subsequences&lt;/h3&gt;
&lt;p&gt;题意 : 给定一个字符串，询问每个合法子序列出现次数的立方和。$n\le 200$&lt;br /&gt;
题解 : 立方和可以转化为3个字符串匹配次数。然后就有一个DP的方法，设$f[i][j][k]$为三个串分别到$i,j,k$且三个位置都相同的方案数，$f[i][j][k]=\sum f[i’][j’][k’]*mp[x[k’],x[j]]$。&lt;br /&gt;
然后拆成三个前缀和，分别前缀和维护即可。&lt;br /&gt;
复杂度$O(n^3)$&lt;/p&gt;
&lt;h3 id=&quot;icpc-2018-徐州-i-rikka-with-sorting-networks&quot;&gt;ICPC 2018 徐州 I Rikka with Sorting Networks&lt;/h3&gt;
&lt;p&gt;题意 : 给定$m$个排序网络，询问有多少排列，在经过该排序网络后，得到一个最长上升子序列长度大于等于$n$的个数。$n\le 50, m\le 10$&lt;br /&gt;
题解 : 长度为$n$的最长上升子序列长度大于等于$n$的排列个数为$(n-2)*n+2$个，然后DFS找到初始排列即可，不同的最终排列得到的初始合法排列不会重复（因为相同排列在经过相同排序网络应得到相同排列）。&lt;/p&gt;

&lt;h3 id=&quot;icpc-2018-徐州-m-rikka-with-illuminations&quot;&gt;ICPC 2018 徐州 M Rikka with Illuminations&lt;/h3&gt;
&lt;p&gt;题意 : 给定$n$个点的凸包，有$m$盏灯，询问最少几盏灯能覆盖整个凸包。$n,m\le1000$&lt;br /&gt;
题解 : 和SRM 655 Hard BichromeSky意外地一样呢，求切线，转换为区间覆盖。这里不需要像那个题统计所有情况，枚举环上断开，每次排序贪心即可。$O(n^2logn)$&lt;/p&gt;

&lt;h2 id=&quot;网络赛&quot;&gt;网络赛&lt;/h2&gt;
&lt;h3 id=&quot;2019-徐州网络赛-f-little-ms-attack-plan&quot;&gt;2019 徐州网络赛 F Little M’s attack plan&lt;/h3&gt;
&lt;p&gt;题意 : 给定一棵树，多次询问距离树上某点距离小于等于$k$的权值和。$n\le 10^6, q\le 5000, k\le 100$&lt;br /&gt;
题解 : 定义以$u$为根的子树中前$k$层的权值和为$f(u,k)$。询问距离一个点$u$距离为$k$的全值和为$f(u,k)+\sum_{i=1}^{k}f(fa^i,k-i+1)-f(fa^{i-1},k-i)$。&lt;br /&gt;
求$f(u,k)$时，维护每个深度的前缀和，在DFS离开和到达这个点$u$时的$sum[dep[u],dep[u]+k]$差即可。&lt;br /&gt;
复杂度$O(qk\log{n})$&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Algorithm" /><summary type="html">ToDoList : TCO14 Round 1A 250 TCO14 Round 1A 500 TCO14 Round 1A 1000 TCO14 Round 1B 200 TCO14 Round 1B 600 TCO14 Round 1B 900 TCO14 Round 1C 250 TCO14 Round 1C 450 TCO14 Round 1C 950 TCO14 Round 2A 250 TCO14 Round 2A 500 TCO14 Round 2A 1000 TCO14 Round 2B 350 TCO14 Round 2B 500 TCO14 Round 2B 900 杭电3 A Azshara’s deep sea 牛客6 F K-ary Heap no 杭电4 D Enveloping Convex Timeline 2019/09/02-2019/09/08 2800-3800 JAG 2009 E Symmetry 2017 SEERC Divide and Conquer 上海网络赛 Counting Sequences II 2018 ICPC 北京 G Solving Equations is Easy 2500-2700 沈阳网络赛 Special necklace 沈阳网络赛 Ghh Matin 沈阳网络赛 Gugugu’s upgrade schemes 2100-2400 2019/09/02-2019/09/08 2800-3800 ICPC 2018 徐州 D Rikka with Subsequences ICPC 2018 徐州 I Rikka with Sorting Networks 2019 徐州网络赛 F Little M’s attack plan JSOI 2018 战争 SCOI 2015 小凸想跑步 2500-2700 2100-2400 2019/08/12-2019/08/19 2800-3800 2018多校9 E Rikka with Rain 牛客10 G Road Construction UVA 1017 World Finals 2002 Merrily, We Roll Along! POJ 1418 Viva Confetti POJ 3384 Feng Shui 2500-2700 2100-2400 2019/08/05-2019/08/11 2800-3800 ICPC 2018 北京 Rikka with Triangles ICPC 2018 徐州 Rikka with Illuminations SRM 595 Constellation(Hard) SRM 573 WolfPack(Hard) SRM 750 PurpleSubsequences(Hard) 2500-2700 2100-2400 2019/07/29-2019/08/04 2800-3800 杭电4 E Good Numbers 杭电4 F Horse 牛客5 F maximum clique 1 2500-2700 杭电4 C Divide the stones 牛客6 E Androgynos 牛客5 C generator 2 牛客5 E independent set 1 牛客5 I three points 1 2100-2400 2019/07/22-2019/07/28 2800-3800 ABC 134 F Permutation Oddness SRM 648 Fragile(Hard) SRM 633 GCDLCM(Hard) 388E Fox and Meteor Shower(3000) 528E Triangles 3000(3000) 2500-2700 2100-2400 牛客4 D triples I 2019/07/15-2019/07/21 2800-3800 SRM 655 BichromeSky(Hard) 1146H Satanic Panic(2800) 1142C U2(2800) 2500-2700 1195F Geometers Anonymous Club(2700) 1194F Crossword Expert(2500) 2100-2400 1190D Tokitsukaze and Strange Rectangle(2200) 1194E Count The Rectangles(2200) 1188B Count Pairs(2200) 1195E OpenStreetMap(2100) Topcoder SRM 754 Medium 题意 : 给定投影等价类数，构造一组点集方案。 题解 : 两个点有两个等价类，对于一个点集，$n^2$条直线去重后的个数为等价类数。构造两列点即可。 Hard 题意 : 给定$4$连通块大小和$8$连通块大小，返回构造结果。 题解 : $8$连通块是由若干$4$连通块组合起来，状压DP一下，DP出一组解。然后按行构造即可。 SRM 753 Hard 题意 : 给定一个序列，区间询问去掉一个数后的最大异或和。 题解 : 可持久化Trie树，区间异或和在区间的Trie树上异或出最大值。 2019 Humblefool Cup Prelims Hard 题意 : 定义相邻的两个质数为只有一个数位不同，且长度相同。询问两个质数可以到达。 题解 : 质数非常连通，预处理之后会发现，只有$4$个块，$2$个是孤点，还有$1$个是大小为$2$的块，剩下的点全部联通。 SRM 752 Hard 题意 : 有$n$个硬币在桌子上，有$1$个硬币在手里，每次抛硬币，正面的话桌面上加$1$个硬币，手里留$1$个硬币，如果桌上有$2N$个硬币则游戏结束。反面的话，从桌上硬币拿走手里的硬币数个放到手里，如果桌上拿空则游戏结束。输出期望场数。 题解 : 转移显然有环，但是由于正面的特殊性，定义$f[i]$表示手里$1$个硬币，桌上$i$个硬币的期望场数。转移方程$f[i]=(f[i+1]+1)*0.5+(f[i]+2)*0.5^2+(f[i-2]+3)*0.5^3+\cdots$。可以发现转移有后效性，但是我们可以将$f[i+1]$去除后效性。 SRM 750 Hard PurpleSubsequences 题意 : 给定一个长度为$n$的序列，询问最长上升子序列长度大于等于$L$的本质不同子序列个数。$n\le 60,x_i\le 20,L\le 6$ 题解 : 本质不同先建出序列自动机，然后在上面大力DP。DP的过程中类似我们直接求解LIS的过程，把保存LIS长度为i的最后一个数字的数组保存在每个节点上。 $O(n^2S)$ SRM 655 Hard 题意 : $n$个红点，$m$个蓝点，没有三点共线，第i个红点以$p_i$的概率出现，求红点的凸包包含所有蓝点的概率。$n, m \le 100$ 题解 : 对于包含所有蓝点的要求，等价于包含所有蓝点形成的凸包。对于一个红点，对蓝点构成的凸包做切线，这两条切线是这个红点的覆盖范围。问题就转化为有$n$个区间，每个区间出现的概率为$p_i$，询问全部覆盖的概率，DP一下即可。 复杂度$O(n^3)$。 SRM 648 Hard Fragile 题意 : 询问有$m$个桥的带标号的$n$个点的图的个数，$n\le 50, 0\le m\le n-1$。 题解 : 首先，我们可以先求出$n$个点$m$个桥的连通图个数，然后背包求答案即可。 然后，对于一个桥，断开之后就变为了两个联通图，所以我们考虑dp求出$f[i][j][k]$为$i$个点，$1$号点所在边双大小为$j$，桥的个数为$k$的方案数。 转移的时候还需要$n$个点的连通图个数，再dp一次求一下。 没有桥的情况拿任意的减去所有有桥的。 复杂度$O(n^5)$。 PS : 做的时候感觉好麻烦，翻了一下别人的，tourist就是dp的，petr打表了，50的数据范围真的是… SRM 633 Hard GCDLCM 题意 : 给定四个数组$A,B,C,D$，构造一个数组$x$使得，当$D[i]=0$时，$C[i]=Gcd(x[A[i]],x[B[i]])$，否则$C[i]=Lcm(x[A[i]],x[B[i]])$。 $n\le 200, C[i]\le 10^9$ 题解 : 这个感觉还不太难。由于$gcd=\Pi p_i^{min(cnt_a,cnt_b)}$，$lcm=\Pi p_i^{max(cnt_a,cnt_b)}$，那么对于$C[i]$，唯一分解得到幂次后，得到了$x[a]$和$x[b]$对于每个质因子的要求，记$x[i]$对质因子$p$的幂次为$cntX[i][p]$，拿gcd举例就是，$min(cntX[a][p],cntX[b][p])=cntD[i][p]$，可以拆成$cntX[a][p]=cntD[i][p]$且$cntX[b][p]\ge cntD[i][p]$或$cntX[a][p]\ge cntD[i][p]$且$cntX[b][p]=cntD[i][p]$。 2-sat判一下即可。 PS : 好久没写2-sat了，写完翻题解的时候翻到了姚老板的blog。 SRM 595 Hard Constellation 题意 : 给定$n$个点，以及他们出现的概率，询问构成凸包的期望面积。$n\le 50$ 题解 : 考虑一个构成凸包内的点，他们出现不出现对于该凸包面积的概率不影响，那么只要考虑在边界的点即可。那么可以想到求凸包面积的方法，是每次求$OA_{i}A_{i+1}$的有向面积。所以枚举两个点，假设他们是凸包上的一条边，即某一侧没有任何点，计算概率。正反各求一次即可。 $O(n^3)$ SRM 573 Hard WolfPack 题意 : 给定$n$个点，每秒每个点可以往上下左右移动一步，询问$m$秒后走到同一个点的方案数。$n\le 50,m\le 10^5$ 题解 : 对于一个点，每次可以$x+1/-1$，$y$不变，或者$y+1/-1$，$x$不变。这里$x$和$y$的变化是相关的，会互相影响，为了消除这种影响可以很自然想到欧几里得距离转切比雪夫距离。 那么我们将其变换后，每次移动变为$x+1/-1$，$y+1/-1$，这样两维就独立了。然后考虑移动到一个点的方案数，问题就是$n$个数轴上的点，每次左右走，询问$m$秒后走到同一位置的方案数。 随便取一个点，枚举$+1$的个数，然后计算其他点走到这个点的方案数。$x$和$y$分开求完乘起来即可。 $O(n^2m)$ TCO 2014 Round 1B Medium WolvesAndSheep 贪心反例 : x[] []v 纯贪心（按行和列分别做一次），不会分割，所以x还是能到达v。 Hard EagleInZoo 题意 : 给定一棵树，从根节点放入动物，如果这个节点已经有动物了，就等概率的选择子节点往下走，重复过程直到有空节点或离开树，一旦离开树，这次的过程停止。询问放入$m$个动物，最后一只留在树上的概率。 题解 : 关键 : 设计状态转移时，要让转移的方案不相交。 $dp[i][j]$表示以$i$为根的子树，放入$j$个动物，最后一只能够留在树上的概率。 转移的时候考虑最后一个动物留在哪个子树，这样使得转移的方案不相交。 假设以$i$为根的子树放入$j$个动物，$i$的子节点数为$c$，枚举进入某个个子树$ch$的动物数$k$，那么概率为${\frac{1}{c}}^{k}*(1-\frac{1}{c})^{j-1-k}*C_{j-2}^{k-1}$ 不管进入别的$ch$的情况是怎么样，所以概率是$1-\frac{1}{c}$ TCO 2014 Round 2A Easy SixteenBricks 题意 : 给定16块$1*1*x[i]$砖，放在$4*4$的格子里，使得可以看见的面积最大。 题解 : 关键 : 首先要大小交替摆放，然后降维分析。 $a&amp;gt;b&amp;gt;c&amp;gt;d$，考虑一维情况$adbc$比$acbd$更优，因为两个的面积分别是$2a+2b-2d$和$2a+2b-2c$，然后放在二维即可。 Medium NarrowPassage 题意 : 在$0$到$l$的走廊里，给定每个物品$n\le 50$的初始位置和目标位置，要改变物品的顺序，必须这些物品在最左端或最右端，询问最小移动步数。 题解 : 关键 : 最优移动的方案。 首先一种情况是，按最开始的位置分成三段，左边一段全部移到最左边，右边一段全部移到最右边，中间一段自行调整。 这种情况的要求是，中间段不能交叉，左边和右边那段的目标位置不能跨越中间那段。 另一种方案是 这类情况的最优方案是，按照起点排序，左边到左端点，右边到右端点，然后按终点排序，枚举边界，右边点的到右端点。 Hard TreePuzzle 题意 : 给定一棵树$(n\le 500)$，给定每个点有无黑点，根节点放一个红点，询问哪些点能被红点到达。 题解 : 关键 : 分类讨论啊。 首先，你现在红点在$x$，黑点分布为$f[x]$，$y$为$x$的一个子节点，判断$y$是否可达。 1.若$y$的子树中空节点数大于等于$1$，则可达。 2.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数为$0$，即$x$的子树中无空节点，则不可达。 3.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数大于等于$2$，则可达。 4.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数等于$1$，记该节点为$z$，其子树中空节点数为$cnt$。 找到$z$的子树中离$z$最近的，且度数大于等于$3$的节点$z’$，若$cnt\ge z$到$z’$的节点数+$2$，则可到达，否则不可到达。 Atcoder ABC 134 F Permutation Oddness 题意 : 对于一个长度为$n$的排列$P$，它的权值为$\sum_{i=1}^{n}|P_i-i|$。现在询问长度为$n$，权值为$m$的排列数。$n\le 50$。 题解 : 首先把这个权值转换一下。这个权值的构成可以看做是两个$1$-$n$顺序排列的匹配，权值为匹配两点的距离差，再转换一下可以看做在$i$和$i+1$($1\le i\le n-1$)中间画一条横线和匹配的线的交点个数。如图: 现在假设我们用左侧的点去匹配右侧的点，每次将左侧的点$i$和比它小的点匹配，和比它大的点匹配由另一侧的点来决定。由另一侧点来决定的点暂且视为闲置点。 假设我们现在匹配完前$i$位了，有$j$个闲置点(左右两侧各$j$个)，那么与$i$和$i+1$中间的直线相交的点的个数为$j$个。 根据这个我们就可以DP了。 $f[i][j][k]$表示前$i$位中有$j$位没有匹配，权值和为$k$的方案数。 $O(1)$转移，复杂度$O(n^4)$ PS : 这题放在ABC很大原因是OEIS能直接找到所有答案的表。所有日文题解都标了”箱根DP”，get不到这个点，但可能在日本已经人尽皆知了吧。 PPS : 有兴趣可以看看这个 https://arxiv.org/pdf/1202.4765.pdf ARC 88 D Wide Flip 题意 : 给定一个长度为$n$的$01$序列，可以翻转一段连续的长度大于$k$的区间，询问最大的$k$。 题解 : 关键 : 假设我们选定了一个$k$，我们能单独修改某些单独位置。 修改第$i\ge k+1$位，可以通过修改$[1,i-1]$和$[1,i]$。 修改第$i\le n-k$位，可以通过修改$[i,n]$和$[i+1,n]$。 到了第$i$和$i+1$位为$01/10$时，我们要修改第$i$和$i+1$位都能达到我们的目的，所以取一个更大的$k$。 $0110010010$ $1\ \ 3\ \ 56\ \ 89\ \ $ $9\ \ 7\ \ 54\ \ 21\ \ $ 可以观察上图，取$\lceil\frac{n}{2}\rceil$一定可以实现目的，因为可以随意修改左右两侧的值，实际上我们要去找的，最靠近中心的01交替的位置，以这个位置对称过去的两侧都可以随意修改，而剩下来中间的部分不用修改。 E Papple Sort 题意 : 给定一个字符串，询问通过交换相邻字符，最少几次能变为回文串。 题解 : 关键 : 1.a…a…a…a，第2个a一定不会越过第3个a，也就是说相同字母的相对位置不变。 2.交换相邻字符我们想到 : 1)可以转化为任意两个位置的交换2)统计答案为求目标位置的逆序对数。 现在转化为求目标位置，回文的话可以看成是一层一层的，结合第一点我们可以确定第1个a一定和最后一个a是一个回文对，然后我们考虑两对的情况。 a..a.b…b a..b.a…b a..b.b…a 分为上面三种，其中第三种显然最终a在b外面，第一种一定会先变成第二种。 而第二种,首先我们假设中间的b和a关于中心对称了，因为不对称要整体平移对于ab谁在外面无影响，然后a在外面我们要右侧a移到右侧b外面，b在外面我们要左侧b移到左侧a外面，因为要对称这两个的操作数是相同的。 所以根据上面三种情况，我们从左向右扫标记每对最终的位置，求一个逆序对即可。 ARC 89 D Checker 题解 : 关键 : 把每个位置的横纵坐标对$2k$取模。 做二维前缀和即可。 ARC 90 E Avoiding Collision 题意 : 给定一张无向图，给定两个点$s$和$t$，两个人分别从$s$和$t$出发，并且都沿着最短路走到$t$和$s$，询问两个人不相遇的方案数。 题解 : 核心是容斥来求，$ans=$最短路对数-到达同一个点的最短路对数-到达同一条边的最短路对数。 先分别求出$s$和$t$到每个点的距离$dis_{1/2}[i]$和最短路方案数$num_{1/2}[i]$，最短路对数为$num_{1}[t]^2$，枚举点，若能作为最短路上的点且两人到达时间相同则计入，枚举边，若能作为最短路上的边且两人在边上能够相遇则计入。 F Number of Digits 题意 : 定义$f(a)$为$a$在十进制中的位数，给定$S(S\le 10^8)$，询问有多少对$l,r$满足，$\sum_{i=l}^{r}f(i)=S$。 题解 : 首先想到$\text{two-point}$，但是$l,r$的范围很大不适用，但但是我们注意到一个关键的性质，当$l\ge10^7$时，因为$f(i)\ge8,i\in[l,r]$，$l$到$r$的距离小于等于$\frac{S}{8}$，所以会得到$f(r)\le f(l)+1$。我们分情况来看一看。 $1.f(l)=f(r)$，此时要求$f(l)|S$，方案数为$9*10^{f(l)-1}-\frac{S}{f(l)}+1$。 $2.f(l)+1=f(r)$，令$t=r-l+1$，$f(l)=\text{len}$，$f(r)=\text{len}+1$，$l$到跨越的距离为$x$，跨越到$r$的距离为$y$，得到等式$S=\text{len}*t+y$，枚举$t$，则$y=S\%t$，$x=t-S\%t$，若$x，y$都大于$0$则计入答案 Codeforces Codeforces Round #574 1195F Geometers Anonymous Club 题意 : 给定$n$个凸包，有$m$次询问，查询在$[l_i,r_i]$中的凸包的闵可夫斯基和的点集大小。 题解 : 回想一下合并两个凸包求闵科夫斯基和的过程，会发现相同斜率的线段只用一次，所以问题转化为求区间中颜色个数，离线树状数组即可。 1195E OpenStreetMap 题意 : 询问在$n\cdot m$的矩阵中，所有$a\cdot b$的子矩阵的最小值的和。$n,m,a,b\le 3000$。 题解 : 先单调栈求一遍每个点横着往左长度为$a$的最小值，再用这个最小值为权值纵向求一个长度为$b$的，最后全加起来即可。$O(nm)$。 Educational Codeforces Round 68 1194F Crossword Expert 题意 : 有$n$个任务，第$i$个任务的完成时间为$t_i$，Bob完成每个任务的时间等概率地为$t_i$或$t_i+1$。现在Bob按顺序完成任务，询问在$m$的时间里，期望完成多少任务。$n\le 2\cdot 10^5, 1\le t_i\le 10^9, m\le 2\cdot 10^{14}$。 题解 : 对于第$i$个任务，完成它的概率为$\frac{\sum_{j=0}^{m-sum[i]}C_{i}^{j}}{2^i}$。 对于$\sum_{j=0}^{a}C_{i}^{j}$转移到$\sum_{j=0}^{a}C_{i+1}^{j}$，可以使用$\sum_{j=0}^{a}C_{i+1}^{j}=2\cdot\sum_{j=0}^{a}C_{i}^{j}-C_{i}^{a}$来实现。 且由于$m-sum[i]$是下降的，所以可以只用求$O(n)$个组合数即可。 1194E Count The Rectangles 题意 : 给定$n$条平行于x轴 或y轴的线段，求一共能围成多少个不同的矩形。$n\le 5000$。 题解 : 把$x$轴平行的线按$y$排序，将$y$轴平行的线拆成两个点(入点和出点)，并按$y$轴排序。 枚举一条$y$轴平行的线，将所有$y$值小于它的点的$x$值加入或删除(入点和出点)，然后按$y$值遍历大于这条平行于$x$轴的线，将$x$值插入和删除，每次查询在这两条平行于$x$轴的线中间合法的$x$值数量即可。$O(n^2\log{n})$。 Codeforces Round #573 1190D Tokitsukaze and Strange Rectangle 题意 : 给定$n$个点，每次使用一个凹字形的框框出一个点集，询问本质不同的点集个数。$n\le 2\cdot 10^5$。 题解 : 先把所有点按$y$轴排序，从大到小，每层统计新加入的点与原来的点形成的贡献，每层结束再把新点加进去。离散化和树状数组处理统计贡献即可。 Codeforces Round #572 1188B Count Pairs 题意 : 给定$n$个值$x_i$，询问有多少对在模$p$意义下满足$(x_i-x_j)\cdot(x_i^2+x_j^2)=k$。$n\le 3\cdot 10^5$ 题解 : 上面的式子乘$x_i+x_j$变为$x_i^4-x_j^4=k(x_i-x_j)$，移项得到$x_i^4-x_i\cdot k=x_j^4-x_j\cdot k$。map处理一下即可。 $O(n\log{n})$ Forethought Future Cup - Elimination Round 1146H Satanic Panic 题意 : 给定平面上$n$个点，询问形成的五角星数量。$n\le 300$ 题解 : 这题有个DP做法，我这里写个组合的。 首先是$C_{n}^{5}$，考虑减掉不合法的情况。 形成合法五角星的5个点，肯定是每个点都在这5个点形成的凸包定点上。 所以，可以分为两种情况：三角形中有两个点，四边形里有一个点。 第一种情况，枚举一个三角形，内部拿两个即可。 第二种情况，枚举一个三角形，在内部拿一个点，外部再拿一个点即可。 可以使用bitset的与和count来求三角形内点的个数。 $O(n^3)$ Codeforces Round #549 1142C U2 题解 : 给定$n$个点，任意两个$x$值不同的点可以求出一个满足$x^2+bx+c=y$的抛物线。询问没有任何点严格在抛物线上方的抛物线个数。$n\le 10^5$。 题意 : 对于一个点$(x_i,y_i)$和他所在的抛物线$x^2+b_ix+c_i=y$，要求满足不存在$y’&amp;gt;x’^2+bx’+c$，这个点所在的抛物线可以表示为$bx_i+c=y_i-x_i^2$，$x_i,y_i$已知，而$b,c$未知，可以将$b,c$看做未知数，每个点转化为$(x_i,y_i-x_i^2)$后可以表示为这条直线上的点，那么任意两个转化后的点的连线就是这条直线。 按照抛物线的要求，要求这条直线上面没有点，即求上凸包。 注意$x$轴值相同的点不算上凸包的点。 $O(n\log{n})$ Codeforces Round #296 528E Triangles 3000 题意 : $n$条直线，等概率挑选$3$条，求围成三角形面积的期望。$n\le 3000$ 题解 : 考虑怎么求构成的所有三角形的面积。 对于三角形的三个顶点逆时针为$A,B,C$，面积可以写为$(OA\times OB+OB\times OC+OC \times OA)/2$，同时这三个点都是交点，那么也就可以转化为，枚举一条直线，直线上的所有交点做叉积即可。 然后对于$OA\times OB+OA\times OC=OA\times(OB+OC)$，极角排序保证逆序，前缀和来维护即可。 Codeforces Round #228 388E Fox and Meteor Shower 题意 : 给出$n$颗流星在$t1$秒和$t2$秒的位置，询问能找到最多多少颗流星，使得两两相交。$n\le 1000$ 题解 : 做的时候没感觉到居然是个讨论题。首先可以看做是个三维直线，那么两两相交的集合就是 : 直线交于同一点或者同一平面且不平行 存到Map里，注意细节。 Educational Codeforces Round 63 F Delivery Oligopoly 题意 : 给一张$n(n\le 15)$个点，$m$条边的双连通图。询问删除最多的边使得新图为双连通图的方案。 题解 : 对于一个双连通图，双连通块的构造方法是一个双连通块加上一条链/一个点。那么我们枚举双连通块点集$s$，枚举一个端点为$i,j$且点集为$t$的链，使得$i,j$分别与$s$内两点相连。 预处理出$i$到点集$s(i\not\in s)$的最大/次大距离，预处理出点集为$s$，左右端点为$i$和$j$的链的最小花费。转移记录方案。 复杂度$O(3^n\cdot n^2)$。 多校 杭电4 C Divide the stones 题意 : 给定重量为$1$-$n$的石头，要求分成重量相等，数量相同的$m$组。$n\le 100000,\sum n\le 500000,m|n$ 题解 : 每堆石子$\frac{n}{m}$个，重量为$\frac{n(1+n)}{2m}$。 分情况讨论，如果$2m|n$，那么两头取即可。否则，除去等于1的情况，$\frac{n}{m}$可以写成$3+a$且$2|a$的形式。这时先构造一个将$1$-$3m$放入$m$组，每组$3$个，再把剩下的放进去即可。 D Enveloping Convex E Good Numbers 题意 : 定义一个数是好的，为$8$进制下每个数码出现次数是$3$的倍数，且该数为$p$的倍数。询问八进制下长度为$n$的好的数有多少。$n\le10^{18},p&amp;lt;8$ 题解 : $f[i][j][k]$表示长度为$i$，每个数码出现次数模$3$的次数，在模$p$下的余数$k$。 BM+打表 F Horse 题意 : 初始能量为$0$，现在要越过$n$棵树，高度为$h_i$，越过一棵树能量减少$h_i$，得到收益为当前能量值。 在越过树前，可以把树吃掉，树的高度变为$0$。 在越过树后，可以休息，恢复能量值为吃掉的所有树的高度和。 最多$m$次休息，$t$次吃树，询问最大收益值。 $n\le10000,m,t\le50,h_i\le10000$ 题解 : 可以发现，得分只在跨越树，休息时能量重置。 现在，我们考虑得分是怎么构成的。对于第$i$棵树，它的得分为 : 上一次休息前吃的树高和$-$上次休息后没吃的树高和$=$上一次休息前吃的树高和$-($上次休息后的树高和$-$上次休息后吃掉的树高和$)=$前$i$棵树中吃掉的树高和$-$上次休息后到$i$的树高和。 这两部分就可以分开计算了。 第一部分，是选择$t$个$h_i$使得$\sum{h_i*(n-i+1)}$最大。 第二部分，是将序列最多分为$m+1$段，使得每段的权值和最小，区间$l,r$的权值为$\sum_{i=l}^{r}h_i\cdot(r-i+1)$。 第一个直接做，第二个是决策单调的。 牛客6 E Androgynos 题意 : 构造点数为$n$的自补图。 题解 : 当$n=4m$或$4m+1$时有解。 $n=4m$时，将$n$个点等距放在一个圆上，从$1$开始标号，奇数点每次向接下来的$[1,m]$点连边。偶数点向后面的$[m+1,2m]$点连边。映射为每个点标号后移一位。 $n=4m+1$时，在$n-1=4m$的连边中，偶数点度数比奇数点度数小$1$，将$n$与偶数点连边即可，$n$映射不动。 F K-ary Heap 题意 : 题解 : 牛客5 C generator 2 题意 : $f_i=a\cdot f_{i-1}+b\cdot f_{i-2}$，求$f_n$。$n\le 10^{10^{6}}$ 题解 : 10进制快速幂。复杂度$O(4\log{n})$ E independent set 1 题意 : 给定一个$n$个点$m$条边的图，询问所有子图的最大独立集之和。$n\le26$ 题解 : 对于一个点集$s$，最大独立集的转移分为，去掉一位和去掉一位的相邻点。 这一位每次选择末位即可包含全部情况。 复杂度$O(2^n)$ F maximum clique 1 题意 : 给定$n$个正整数$x_i$，选出一个集合$S$，满足任意两个数二进制下至少两位不同，询问最大$|S|$。$n\le 5000,x_i\le 10^9$ 题解 : 按题意建图是求最大团，最大团和最大独立集是互补的，所以把条件反过来建立补图，即任意两个数二进制下最多一位不同，由于是集合任意两数不同，所以是任意两数二进制下只有一位不同。 证明该图是二分图，等价于证明没有奇环。考虑一个数$a$所在的环为奇环，该环上的点$x$与$a$的不同位数记为$f(x)$。$a$邻接的两个环上的点$f(x)$都为$1$，每次走一步可以使得$f(x)$加一或减一，且$f(x)$永远不为$0$，所以环长不为奇数，所以是二分图。按1的个数的奇偶也很好证。 求二分图最大独立集即可。 每个点有一位不同的点最多$30$个，所以边数为$30n$，复杂度$O(30n^2)$ 输出方案时，输出左侧未匹配点和右侧匹配点。做完二分图匹配后再将所有左侧未匹配点dfs一次，右侧没有被遍历到的点就是合法点。 I three points 1 题意 : 给定三角形边长，将其放入给定的矩形中，输出一组解。 题解 : 别写什么swap了，排列就完事了。 牛客 4 D triples I 题意 : 询问$n$由最少几个三的倍数或起来得到，输出方案。 题解 : 题目保证输入都有解，那么如果不是三的倍数最少就是2个数。 $f[i][j][k]$为前$i$位，第一个数模3的为$j$，第二个数模3的为$k$的解。 DP比直接做会多个10的倍数。 Regional ICPC 2018 北京 Rikka with Triangles 题意 : 给定$n$个点，询问锐角三角形个数和总面积。$n\le2000$，坐标范围$\le10^{18}$ 题解 : 首先，锐角三角形不好判断，为什么？比较一下三种三角形，锐角三角形三个角都是锐角，直角三角形和钝角三角形只有一个角是非锐角，所以我们考虑反着求。 首先，求钝角三角形个数和直角三角形个数。枚举一个点求以这个点为钝角/直角，然后极角排序，满足为大于/等于90度且小于180度的点可以双指针来统计。$O(n^2logn)$ 其中，$C_{n}^{3}$中会包括三点共线的情况，也要统计。枚举一个点，极角排序，统计$[0,\pi)$的三点共线。$O(n^2logn)$ 面积还是考虑求钝角和直角三角形的面积。和CodeForces 528E Triangles 3000的思路一样，钝角和直角，极角排序，双指针，前缀和优化。总面积和就是528E。$O(n^2logn)$ 这里面极角排序用象限和叉积，使用全整数，__int128。 ICPC 2018 徐州 D Rikka with Subsequences 题意 : 给定一个字符串，询问每个合法子序列出现次数的立方和。$n\le 200$ 题解 : 立方和可以转化为3个字符串匹配次数。然后就有一个DP的方法，设$f[i][j][k]$为三个串分别到$i,j,k$且三个位置都相同的方案数，$f[i][j][k]=\sum f[i’][j’][k’]*mp[x[k’],x[j]]$。 然后拆成三个前缀和，分别前缀和维护即可。 复杂度$O(n^3)$ ICPC 2018 徐州 I Rikka with Sorting Networks 题意 : 给定$m$个排序网络，询问有多少排列，在经过该排序网络后，得到一个最长上升子序列长度大于等于$n$的个数。$n\le 50, m\le 10$ 题解 : 长度为$n$的最长上升子序列长度大于等于$n$的排列个数为$(n-2)*n+2$个，然后DFS找到初始排列即可，不同的最终排列得到的初始合法排列不会重复（因为相同排列在经过相同排序网络应得到相同排列）。 ICPC 2018 徐州 M Rikka with Illuminations 题意 : 给定$n$个点的凸包，有$m$盏灯，询问最少几盏灯能覆盖整个凸包。$n,m\le1000$ 题解 : 和SRM 655 Hard BichromeSky意外地一样呢，求切线，转换为区间覆盖。这里不需要像那个题统计所有情况，枚举环上断开，每次排序贪心即可。$O(n^2logn)$ 网络赛 2019 徐州网络赛 F Little M’s attack plan 题意 : 给定一棵树，多次询问距离树上某点距离小于等于$k$的权值和。$n\le 10^6, q\le 5000, k\le 100$ 题解 : 定义以$u$为根的子树中前$k$层的权值和为$f(u,k)$。询问距离一个点$u$距离为$k$的全值和为$f(u,k)+\sum_{i=1}^{k}f(fa^i,k-i+1)-f(fa^{i-1},k-i)$。 求$f(u,k)$时，维护每个深度的前缀和，在DFS离开和到达这个点$u$时的$sum[dep[u],dep[u]+k]$差即可。 复杂度$O(qk\log{n})$</summary></entry><entry><title type="html">Work for Open Source Community Using Git</title><link href="http://localhost:3798/2019/03/19/Work-for-Open-Source-Community-Using-Git.html" rel="alternate" type="text/html" title="Work for Open Source Community Using Git" /><published>2019-03-19T00:00:00+08:00</published><updated>2019-03-19T00:00:00+08:00</updated><id>http://localhost:3798/2019/03/19/Work%20for%20Open%20Source%20Community%20Using%20Git</id><content type="html" xml:base="http://localhost:3798/2019/03/19/Work-for-Open-Source-Community-Using-Git.html">&lt;p&gt;长期更新使用Git和Github工作的内容。&lt;/p&gt;

&lt;h2 id=&quot;案例展示&quot;&gt;案例展示&lt;/h2&gt;
&lt;h3 id=&quot;pr工作流程&quot;&gt;PR工作流程&lt;/h3&gt;
&lt;h4 id=&quot;场景描述&quot;&gt;场景描述&lt;/h4&gt;
&lt;p&gt;第一个场景是大家最常遇到的。 &lt;br /&gt;
先从开源项目那边fork过来，然后clone到本地，准备工作，打算修改完代码再push回去，提交PR。&lt;/p&gt;
&lt;h4 id=&quot;工作流程&quot;&gt;工作流程&lt;/h4&gt;
&lt;p&gt;上面提到的流程听起来非常理想，但是对那些对Git没什么经验的人来说，有非常多的坑存在。&lt;br /&gt;
1.首先我们要时刻保持fork的分支的master分支是与官方的master分支一致。&lt;br /&gt;
2.然后在你本地的master分支上面新建一个new分支，然后在这个new分支上工作。&lt;br /&gt;
前两点很重要，很多人一开始就直接在master分支上面干活，后面会造成非常多的麻烦。&lt;br /&gt;
3.在new分支上干活。&lt;br /&gt;
4.和远程的new分支同步。&lt;br /&gt;
5.在Github上面，你的fork仓库里点击PR，提交PR到官方仓库。&lt;br /&gt;
假设现在我们已经完成工作了，这个PR，我们提交了很多条commit。  &lt;br /&gt;
6.将new分支上的commit，rebase成1条commit到你的master分支，等待merge。  &lt;br /&gt;
在PR被merge后，你的fork分支会落后官方分支，接下来要更新你的fork分支。&lt;br /&gt;
这时我们需要有一个新的merge分支用来merge新的commit，这个merge分支建立在你的master分支上。&lt;br /&gt;
7.点击github上面的compare，比较你的merge分支和官方master分支，将官方master分支上新的commit以PR的形式加到你的merge分支上。&lt;br /&gt;
9.将你merge分支上面的commit以rebase的形式放到你的master分支上。&lt;br /&gt;
10.删除你的merge分支和new分支。&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Git" /><summary type="html">长期更新使用Git和Github工作的内容。 案例展示 PR工作流程 场景描述 第一个场景是大家最常遇到的。 先从开源项目那边fork过来，然后clone到本地，准备工作，打算修改完代码再push回去，提交PR。 工作流程 上面提到的流程听起来非常理想，但是对那些对Git没什么经验的人来说，有非常多的坑存在。 1.首先我们要时刻保持fork的分支的master分支是与官方的master分支一致。 2.然后在你本地的master分支上面新建一个new分支，然后在这个new分支上工作。 前两点很重要，很多人一开始就直接在master分支上面干活，后面会造成非常多的麻烦。 3.在new分支上干活。 4.和远程的new分支同步。 5.在Github上面，你的fork仓库里点击PR，提交PR到官方仓库。 假设现在我们已经完成工作了，这个PR，我们提交了很多条commit。 6.将new分支上的commit，rebase成1条commit到你的master分支，等待merge。 在PR被merge后，你的fork分支会落后官方分支，接下来要更新你的fork分支。 这时我们需要有一个新的merge分支用来merge新的commit，这个merge分支建立在你的master分支上。 7.点击github上面的compare，比较你的merge分支和官方master分支，将官方master分支上新的commit以PR的形式加到你的merge分支上。 9.将你merge分支上面的commit以rebase的形式放到你的master分支上。 10.删除你的merge分支和new分支。</summary></entry></feed>
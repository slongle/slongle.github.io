<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:1727/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:1727/" rel="alternate" type="text/html" /><updated>2019-04-22T16:33:37+08:00</updated><id>http://localhost:1727/feed.xml</id><title type="html">slongle</title><subtitle></subtitle><author><name>slongle</name><email>junchendeng@gmail.com</email></author><entry><title type="html">Last Time</title><link href="http://localhost:1727/2019/04/10/Last-Time.html" rel="alternate" type="text/html" title="Last Time" /><published>2019-04-10T00:00:00+08:00</published><updated>2019-04-10T00:00:00+08:00</updated><id>http://localhost:1727/2019/04/10/Last%20Time</id><content type="html" xml:base="http://localhost:1727/2019/04/10/Last-Time.html">&lt;h2 id=&quot;todolist&quot;&gt;ToDoList：&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;[x]TCO14 Round 1A 250&lt;/li&gt;
  &lt;li&gt;[x]TCO14 Round 1A 500&lt;/li&gt;
  &lt;li&gt;[ ]TCO14 Round 1A 1000&lt;/li&gt;
  &lt;li&gt;[ ]TCO14 Round 1B 200&lt;/li&gt;
  &lt;li&gt;[x]TCO14 Round 1B 600&lt;/li&gt;
  &lt;li&gt;[x]TCO14 Round 1B 900&lt;/li&gt;
  &lt;li&gt;[x]TCO14 Round 1C 250&lt;/li&gt;
  &lt;li&gt;[x]TCO14 Round 1C 450&lt;/li&gt;
  &lt;li&gt;[x]TCO14 Round 1C 950&lt;/li&gt;
  &lt;li&gt;[x]TCO14 Round 2A 250&lt;/li&gt;
  &lt;li&gt;[x]TCO14 Round 2A 500&lt;/li&gt;
  &lt;li&gt;[ ]TCO14 Round 2A 1000&lt;/li&gt;
  &lt;li&gt;[x]TCO14 Round 2B 350&lt;/li&gt;
  &lt;li&gt;[x]TCO14 Round 2B 500&lt;/li&gt;
  &lt;li&gt;[ ]TCO14 Round 2B 900&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;topcoder&quot;&gt;Topcoder&lt;/h2&gt;

&lt;h3 id=&quot;srm-754&quot;&gt;SRM 754&lt;/h3&gt;
&lt;h4 id=&quot;medium&quot;&gt;Medium&lt;/h4&gt;
&lt;p&gt;题意 : 给定投影等价类数，构造一组点集方案。&lt;br /&gt;
题解 : 两个点有两个等价类，对于一个点集，$n^2$条直线去重后的个数为等价类数。构造两列点即可。&lt;/p&gt;
&lt;h4 id=&quot;hard&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 给定$4$连通块大小和$8$连通块大小，返回构造结果。&lt;br /&gt;
题解 : $8$连通块是由若干$4$连通块组合起来，状压DP一下，DP出一组解。然后按行构造即可。&lt;/p&gt;

&lt;h3 id=&quot;srm-753&quot;&gt;SRM 753&lt;/h3&gt;
&lt;h4 id=&quot;hard-1&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 给定一个序列，区间询问去掉一个数后的最大异或和。&lt;br /&gt;
题解 : 可持久化Trie树，区间异或和在区间的Trie树上异或出最大值。&lt;/p&gt;

&lt;h3 id=&quot;2019-humblefool-cup-prelims&quot;&gt;2019 Humblefool Cup Prelims&lt;/h3&gt;
&lt;h4 id=&quot;hard-2&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 定义相邻的两个质数为只有一个数位不同，且长度相同。询问两个质数可以到达。&lt;br /&gt;
题解 : 质数非常连通，预处理之后会发现，只有$4$个块，$2$个是孤点，还有$1$个是大小为$2$的块，剩下的点全部联通。&lt;/p&gt;

&lt;h3 id=&quot;srm-752&quot;&gt;SRM 752&lt;/h3&gt;
&lt;h4 id=&quot;hard-3&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 有$n$个硬币在桌子上，有$1$个硬币在手里，每次抛硬币，正面的话桌面上加$1$个硬币，手里留$1$个硬币，如果桌上有$2N$个硬币则游戏结束。反面的话，从桌上硬币拿走手里的硬币数个放到手里，如果桌上拿空则游戏结束。输出期望场数。&lt;br /&gt;
题解 : 转移显然有环，但是由于正面的特殊性，定义$f[i]$表示手里$1$个硬币，桌上$i$个硬币的期望场数。转移方程$f[i]=(f[i+1]+1)*0.5+(f[i]+2)*0.5^2+(f[i-2]+3)*0.5^3+\cdots$。可以发现转移有后效性，但是我们可以将$f[i+1]$去除后效性。&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-1b&quot;&gt;TCO 2014 Round 1B&lt;/h3&gt;
&lt;h4 id=&quot;medium-wolvesandsheep&quot;&gt;Medium WolvesAndSheep&lt;/h4&gt;
&lt;p&gt;贪心反例：&lt;br /&gt;
x[]&lt;br /&gt;
[]v&lt;br /&gt;
纯贪心（按行和列分别做一次），不会分割，所以x还是能到达v。&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-1b-1&quot;&gt;TCO 2014 Round 1B&lt;/h3&gt;
&lt;h4 id=&quot;hard-eagleinzoo&quot;&gt;Hard EagleInZoo&lt;/h4&gt;
&lt;p&gt;题意：给定一棵树，从根节点放入动物，如果这个节点已经有动物了，就等概率的选择子节点往下走，重复过程直到有空节点或离开树，一旦离开树，这次的过程停止。询问放入$m$个动物，最后一只留在树上的概率。  &lt;br /&gt;
题解：关键：设计状态转移时，要让转移的方案不相交。&lt;br /&gt;
$dp[i][j]$表示以$i$为根的子树，放入$j$个动物，最后一只能够留在树上的概率。&lt;br /&gt;
转移的时候考虑最后一个动物留在哪个子树，这样使得转移的方案不相交。&lt;br /&gt;
假设以$i$为根的子树放入$j$个动物，$i$的子节点数为$c$，枚举进入某个个子树$ch$的动物数$k$，那么概率为${\frac{1}{c}}^{k}*(1-\frac{1}{c})^{j-1-k}*C_{j-2}^{k-1}$
不管进入别的$ch$的情况是怎么样，所以概率是$1-\frac{1}{c}$&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-2a&quot;&gt;TCO 2014 Round 2A&lt;/h3&gt;
&lt;h4 id=&quot;easy-sixteenbricks&quot;&gt;Easy SixteenBricks&lt;/h4&gt;
&lt;p&gt;题意：给定16块$1*1*x[i]$砖，放在$4*4$的格子里，使得可以看见的面积最大。&lt;br /&gt;
题解：关键：首先要大小交替摆放，然后降维分析。&lt;br /&gt;
$a&amp;gt;b&amp;gt;c&amp;gt;d$，考虑一维情况$adbc$比$acbd$更优，因为两个的面积分别是$2a+2b-2d$和$2a+2b-2c$，然后放在二维即可。&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-2a-1&quot;&gt;TCO 2014 Round 2A&lt;/h3&gt;
&lt;h4 id=&quot;medium-narrowpassage&quot;&gt;Medium NarrowPassage&lt;/h4&gt;
&lt;p&gt;题意：在$0$到$l$的走廊里，给定每个物品$n\le 50$的初始位置和目标位置，要改变物品的顺序，必须这些物品在最左端或最右端，询问最小移动步数。&lt;br /&gt;
题解：关键：最优移动的方案。&lt;br /&gt;
首先一种情况是，按最开始的位置分成三段，左边一段全部移到最左边，右边一段全部移到最右边，中间一段自行调整。&lt;br /&gt;
这种情况的要求是，中间段不能交叉，左边和右边那段的目标位置不能跨越中间那段。&lt;br /&gt;
另一种方案是&lt;img src=&quot;http://7xs2ho.com1.z0.glb.clouddn.com/0013.png&quot; alt=&quot;&quot; /&gt;
这类情况的最优方案是，按照起点排序，左边到左端点，右边到右端点，然后按终点排序，枚举边界，右边点的到右端点。&lt;/p&gt;

&lt;h3 id=&quot;tco-2014-round-2a-2&quot;&gt;TCO 2014 Round 2A&lt;/h3&gt;
&lt;h4 id=&quot;hard-treepuzzle&quot;&gt;Hard TreePuzzle&lt;/h4&gt;
&lt;p&gt;题意：给定一棵树$(n\le 500)$，给定每个点有无黑点，根节点放一个红点，询问哪些点能被红点到达。&lt;br /&gt;
题解：关键：分类讨论啊。&lt;br /&gt;
首先，你现在红点在$x$，黑点分布为$f[x]$，$y$为$x$的一个子节点，判断$y$是否可达。&lt;br /&gt;
1.若$y$的子树中空节点数大于等于$1$，则可达。&lt;br /&gt;
2.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数为$0$，即$x$的子树中无空节点，则不可达。&lt;br /&gt;
3.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数大于等于$2$，则可达。&lt;br /&gt;
4.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数等于$1$，记该节点为$z$，其子树中空节点数为$cnt$。&lt;br /&gt;
找到$z$的子树中离$z$最近的，且度数大于等于$3$的节点$z’$，若$cnt\ge z$到$z’$的节点数+$2$，则可到达，否则不可到达。&lt;/p&gt;

&lt;h2 id=&quot;atcoder&quot;&gt;Atcoder&lt;/h2&gt;
&lt;h3 id=&quot;arc-88&quot;&gt;ARC 88&lt;/h3&gt;
&lt;h4 id=&quot;d-wide-flip&quot;&gt;D Wide Flip&lt;/h4&gt;
&lt;p&gt;题意：给定一个长度为$n$的$01$序列，可以翻转一段连续的长度大于$k$的区间，询问最大的$k$。&lt;br /&gt;
题解：关键：假设我们选定了一个$k$，我们能单独修改某些单独位置。&lt;br /&gt;
修改第$i\ge k+1$位，可以通过修改$[1,i-1]$和$[1,i]$。&lt;br /&gt;
修改第$i\le n-k$位，可以通过修改$[i,n]$和$[i+1,n]$。&lt;br /&gt;
到了第$i$和$i+1$位为$01/10$时，我们要修改第$i$和$i+1$位都能达到我们的目的，所以取一个更大的$k$。&lt;br /&gt;
$0110010010$&lt;br /&gt;
$1\ \ 3\ \ 56\ \ 89\ \ $  &lt;br /&gt;
$9\ \ 7\ \ 54\ \ 21\ \ $  &lt;br /&gt;
可以观察上图，取$\lceil\frac{n}{2}\rceil$一定可以实现目的，因为可以随意修改左右两侧的值，实际上我们要去找的，最靠近中心的01交替的位置，以这个位置对称过去的两侧都可以随意修改，而剩下来中间的部分不用修改。&lt;/p&gt;
&lt;h4 id=&quot;e-papple-sort&quot;&gt;E Papple Sort&lt;/h4&gt;
&lt;p&gt;题意：给定一个字符串，询问通过交换相邻字符，最少几次能变为回文串。  &lt;br /&gt;
题解：关键：&lt;br /&gt;
1.a…a…a…a，第2个a一定不会越过第3个a，也就是说相同字母的相对位置不变。&lt;br /&gt;
2.交换相邻字符我们想到：1)可以转化为任意两个位置的交换2)统计答案为求目标位置的逆序对数。&lt;br /&gt;
现在转化为求目标位置，回文的话可以看成是一层一层的，结合第一点我们可以确定第1个a一定和最后一个a是一个回文对，然后我们考虑两对的情况。&lt;br /&gt;
a..a.b…b&lt;br /&gt;
a..b.a…b&lt;br /&gt;
a..b.b…a&lt;br /&gt;
分为上面三种，其中第三种显然最终a在b外面，第一种一定会先变成第二种。&lt;br /&gt;
而第二种,首先我们假设中间的b和a关于中心对称了，因为不对称要整体平移对于ab谁在外面无影响，然后a在外面我们要右侧a移到右侧b外面，b在外面我们要左侧b移到左侧a外面，因为要对称这两个的操作数是相同的。&lt;br /&gt;
所以根据上面三种情况，我们从左向右扫标记每对最终的位置，求一个逆序对即可。&lt;/p&gt;

&lt;h3 id=&quot;arc-89&quot;&gt;ARC 89&lt;/h3&gt;
&lt;h4 id=&quot;d-checker&quot;&gt;D Checker&lt;/h4&gt;
&lt;p&gt;题解：关键：把每个位置的横纵坐标对$2k$取模。&lt;br /&gt;
做二维前缀和即可。&lt;/p&gt;

&lt;h3 id=&quot;arc-90&quot;&gt;ARC 90&lt;/h3&gt;
&lt;h4 id=&quot;e-avoiding-collision&quot;&gt;E Avoiding Collision&lt;/h4&gt;
&lt;p&gt;题意：给定一张无向图，给定两个点$s$和$t$，两个人分别从$s$和$t$出发，并且都沿着最短路走到$t$和$s$，询问两个人不相遇的方案数。  &lt;br /&gt;
题解：核心是容斥来求，$ans=$最短路对数-到达同一个点的最短路对数-到达同一条边的最短路对数。&lt;br /&gt;
先分别求出$s$和$t$到每个点的距离$dis_{1/2}[i]$和最短路方案数$num_{1/2}[i]$，最短路对数为$num_{1}[t]^2$，枚举点，若能作为最短路上的点且两人到达时间相同则计入，枚举边，若能作为最短路上的边且两人在边上能够相遇则计入。&lt;/p&gt;

&lt;h4 id=&quot;f-number-of-digits&quot;&gt;F Number of Digits&lt;/h4&gt;
&lt;p&gt;题意：定义$f(a)$为$a$在十进制中的位数，给定$S(S\le 10^8)$，询问有多少对$l,r$满足，$\sum_{i=l}^{r}f(i)=S$。  &lt;br /&gt;
题解：首先想到$\text{two-point}$，但是$l,r$的范围很大不适用，但但是我们注意到一个关键的性质，当$l\ge10^7$时，因为$f(i)\ge8,i\in[l,r]$，$l$到$r$的距离小于等于$\frac{S}{8}$，所以会得到$f(r)\le f(l)+1$。我们分情况来看一看。&lt;br /&gt;
$1.f(l)=f(r)$，此时要求$f(l)|S$，方案数为$9*10^{f(l)-1}-\frac{S}{f(l)}+1$。&lt;br /&gt;
$2.f(l)+1=f(r)$，令$t=r-l+1$，$f(l)=\text{len}$，$f(r)=\text{len}+1$，$l$到跨越的距离为$x$，跨越到$r$的距离为$y$，得到等式$S=\text{len}*t+y$，枚举$t$，则$y=S\%t$，$x=t-S\%t$，若$x，y$都大于$0$则计入答案&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Algorithm" /><summary type="html">ToDoList： [x]TCO14 Round 1A 250 [x]TCO14 Round 1A 500 [ ]TCO14 Round 1A 1000 [ ]TCO14 Round 1B 200 [x]TCO14 Round 1B 600 [x]TCO14 Round 1B 900 [x]TCO14 Round 1C 250 [x]TCO14 Round 1C 450 [x]TCO14 Round 1C 950 [x]TCO14 Round 2A 250 [x]TCO14 Round 2A 500 [ ]TCO14 Round 2A 1000 [x]TCO14 Round 2B 350 [x]TCO14 Round 2B 500 [ ]TCO14 Round 2B 900 Topcoder SRM 754 Medium 题意 : 给定投影等价类数，构造一组点集方案。 题解 : 两个点有两个等价类，对于一个点集，$n^2$条直线去重后的个数为等价类数。构造两列点即可。 Hard 题意 : 给定$4$连通块大小和$8$连通块大小，返回构造结果。 题解 : $8$连通块是由若干$4$连通块组合起来，状压DP一下，DP出一组解。然后按行构造即可。 SRM 753 Hard 题意 : 给定一个序列，区间询问去掉一个数后的最大异或和。 题解 : 可持久化Trie树，区间异或和在区间的Trie树上异或出最大值。 2019 Humblefool Cup Prelims Hard 题意 : 定义相邻的两个质数为只有一个数位不同，且长度相同。询问两个质数可以到达。 题解 : 质数非常连通，预处理之后会发现，只有$4$个块，$2$个是孤点，还有$1$个是大小为$2$的块，剩下的点全部联通。 SRM 752 Hard 题意 : 有$n$个硬币在桌子上，有$1$个硬币在手里，每次抛硬币，正面的话桌面上加$1$个硬币，手里留$1$个硬币，如果桌上有$2N$个硬币则游戏结束。反面的话，从桌上硬币拿走手里的硬币数个放到手里，如果桌上拿空则游戏结束。输出期望场数。 题解 : 转移显然有环，但是由于正面的特殊性，定义$f[i]$表示手里$1$个硬币，桌上$i$个硬币的期望场数。转移方程$f[i]=(f[i+1]+1)*0.5+(f[i]+2)*0.5^2+(f[i-2]+3)*0.5^3+\cdots$。可以发现转移有后效性，但是我们可以将$f[i+1]$去除后效性。 TCO 2014 Round 1B Medium WolvesAndSheep 贪心反例： x[] []v 纯贪心（按行和列分别做一次），不会分割，所以x还是能到达v。 TCO 2014 Round 1B Hard EagleInZoo 题意：给定一棵树，从根节点放入动物，如果这个节点已经有动物了，就等概率的选择子节点往下走，重复过程直到有空节点或离开树，一旦离开树，这次的过程停止。询问放入$m$个动物，最后一只留在树上的概率。 题解：关键：设计状态转移时，要让转移的方案不相交。 $dp[i][j]$表示以$i$为根的子树，放入$j$个动物，最后一只能够留在树上的概率。 转移的时候考虑最后一个动物留在哪个子树，这样使得转移的方案不相交。 假设以$i$为根的子树放入$j$个动物，$i$的子节点数为$c$，枚举进入某个个子树$ch$的动物数$k$，那么概率为${\frac{1}{c}}^{k}*(1-\frac{1}{c})^{j-1-k}*C_{j-2}^{k-1}$ 不管进入别的$ch$的情况是怎么样，所以概率是$1-\frac{1}{c}$ TCO 2014 Round 2A Easy SixteenBricks 题意：给定16块$1*1*x[i]$砖，放在$4*4$的格子里，使得可以看见的面积最大。 题解：关键：首先要大小交替摆放，然后降维分析。 $a&amp;gt;b&amp;gt;c&amp;gt;d$，考虑一维情况$adbc$比$acbd$更优，因为两个的面积分别是$2a+2b-2d$和$2a+2b-2c$，然后放在二维即可。 TCO 2014 Round 2A Medium NarrowPassage 题意：在$0$到$l$的走廊里，给定每个物品$n\le 50$的初始位置和目标位置，要改变物品的顺序，必须这些物品在最左端或最右端，询问最小移动步数。 题解：关键：最优移动的方案。 首先一种情况是，按最开始的位置分成三段，左边一段全部移到最左边，右边一段全部移到最右边，中间一段自行调整。 这种情况的要求是，中间段不能交叉，左边和右边那段的目标位置不能跨越中间那段。 另一种方案是 这类情况的最优方案是，按照起点排序，左边到左端点，右边到右端点，然后按终点排序，枚举边界，右边点的到右端点。 TCO 2014 Round 2A Hard TreePuzzle 题意：给定一棵树$(n\le 500)$，给定每个点有无黑点，根节点放一个红点，询问哪些点能被红点到达。 题解：关键：分类讨论啊。 首先，你现在红点在$x$，黑点分布为$f[x]$，$y$为$x$的一个子节点，判断$y$是否可达。 1.若$y$的子树中空节点数大于等于$1$，则可达。 2.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数为$0$，即$x$的子树中无空节点，则不可达。 3.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数大于等于$2$，则可达。 4.若$y$的子树中空节点数等于$0$，且$x$的子节点中，子树中空节点数大于等于$1$的个数等于$1$，记该节点为$z$，其子树中空节点数为$cnt$。 找到$z$的子树中离$z$最近的，且度数大于等于$3$的节点$z’$，若$cnt\ge z$到$z’$的节点数+$2$，则可到达，否则不可到达。 Atcoder ARC 88 D Wide Flip 题意：给定一个长度为$n$的$01$序列，可以翻转一段连续的长度大于$k$的区间，询问最大的$k$。 题解：关键：假设我们选定了一个$k$，我们能单独修改某些单独位置。 修改第$i\ge k+1$位，可以通过修改$[1,i-1]$和$[1,i]$。 修改第$i\le n-k$位，可以通过修改$[i,n]$和$[i+1,n]$。 到了第$i$和$i+1$位为$01/10$时，我们要修改第$i$和$i+1$位都能达到我们的目的，所以取一个更大的$k$。 $0110010010$ $1\ \ 3\ \ 56\ \ 89\ \ $ $9\ \ 7\ \ 54\ \ 21\ \ $ 可以观察上图，取$\lceil\frac{n}{2}\rceil$一定可以实现目的，因为可以随意修改左右两侧的值，实际上我们要去找的，最靠近中心的01交替的位置，以这个位置对称过去的两侧都可以随意修改，而剩下来中间的部分不用修改。 E Papple Sort 题意：给定一个字符串，询问通过交换相邻字符，最少几次能变为回文串。 题解：关键： 1.a…a…a…a，第2个a一定不会越过第3个a，也就是说相同字母的相对位置不变。 2.交换相邻字符我们想到：1)可以转化为任意两个位置的交换2)统计答案为求目标位置的逆序对数。 现在转化为求目标位置，回文的话可以看成是一层一层的，结合第一点我们可以确定第1个a一定和最后一个a是一个回文对，然后我们考虑两对的情况。 a..a.b…b a..b.a…b a..b.b…a 分为上面三种，其中第三种显然最终a在b外面，第一种一定会先变成第二种。 而第二种,首先我们假设中间的b和a关于中心对称了，因为不对称要整体平移对于ab谁在外面无影响，然后a在外面我们要右侧a移到右侧b外面，b在外面我们要左侧b移到左侧a外面，因为要对称这两个的操作数是相同的。 所以根据上面三种情况，我们从左向右扫标记每对最终的位置，求一个逆序对即可。 ARC 89 D Checker 题解：关键：把每个位置的横纵坐标对$2k$取模。 做二维前缀和即可。 ARC 90 E Avoiding Collision 题意：给定一张无向图，给定两个点$s$和$t$，两个人分别从$s$和$t$出发，并且都沿着最短路走到$t$和$s$，询问两个人不相遇的方案数。 题解：核心是容斥来求，$ans=$最短路对数-到达同一个点的最短路对数-到达同一条边的最短路对数。 先分别求出$s$和$t$到每个点的距离$dis_{1/2}[i]$和最短路方案数$num_{1/2}[i]$，最短路对数为$num_{1}[t]^2$，枚举点，若能作为最短路上的点且两人到达时间相同则计入，枚举边，若能作为最短路上的边且两人在边上能够相遇则计入。 F Number of Digits 题意：定义$f(a)$为$a$在十进制中的位数，给定$S(S\le 10^8)$，询问有多少对$l,r$满足，$\sum_{i=l}^{r}f(i)=S$。 题解：首先想到$\text{two-point}$，但是$l,r$的范围很大不适用，但但是我们注意到一个关键的性质，当$l\ge10^7$时，因为$f(i)\ge8,i\in[l,r]$，$l$到$r$的距离小于等于$\frac{S}{8}$，所以会得到$f(r)\le f(l)+1$。我们分情况来看一看。 $1.f(l)=f(r)$，此时要求$f(l)|S$，方案数为$9*10^{f(l)-1}-\frac{S}{f(l)}+1$。 $2.f(l)+1=f(r)$，令$t=r-l+1$，$f(l)=\text{len}$，$f(r)=\text{len}+1$，$l$到跨越的距离为$x$，跨越到$r$的距离为$y$，得到等式$S=\text{len}*t+y$，枚举$t$，则$y=S\%t$，$x=t-S\%t$，若$x，y$都大于$0$则计入答案</summary></entry><entry><title type="html">Work for Open Source Community Using Git</title><link href="http://localhost:1727/2019/03/19/Work-for-Open-Source-Community-Using-Git.html" rel="alternate" type="text/html" title="Work for Open Source Community Using Git" /><published>2019-03-19T00:00:00+08:00</published><updated>2019-03-19T00:00:00+08:00</updated><id>http://localhost:1727/2019/03/19/Work%20for%20Open%20Source%20Community%20Using%20Git</id><content type="html" xml:base="http://localhost:1727/2019/03/19/Work-for-Open-Source-Community-Using-Git.html">&lt;p&gt;长期更新使用Git和Github工作的内容。&lt;/p&gt;

&lt;h2 id=&quot;案例展示&quot;&gt;案例展示&lt;/h2&gt;
&lt;h3 id=&quot;pr工作流程&quot;&gt;PR工作流程&lt;/h3&gt;
&lt;h4 id=&quot;场景描述&quot;&gt;场景描述&lt;/h4&gt;
&lt;p&gt;第一个场景是大家最常遇到的。 &lt;br /&gt;
先从开源项目那边fork过来，然后clone到本地，准备工作，打算修改完代码再push回去，提交PR。&lt;/p&gt;
&lt;h4 id=&quot;工作流程&quot;&gt;工作流程&lt;/h4&gt;
&lt;p&gt;上面提到的流程听起来非常理想，但是对那些对Git没什么经验的人来说，有非常多的坑存在。&lt;br /&gt;
1.首先我们要时刻保持fork的分支的master分支是与官方的master分支一致。&lt;br /&gt;
2.然后在你本地的master分支上面新建一个new分支，然后在这个new分支上工作。&lt;br /&gt;
前两点很重要，很多人一开始就直接在master分支上面干活，后面会造成非常多的麻烦。&lt;br /&gt;
3.在new分支上干活。&lt;br /&gt;
4.和远程的new分支同步。&lt;br /&gt;
5.在Github上面，你的fork仓库里点击PR，提交PR到官方仓库。&lt;br /&gt;
假设现在我们已经完成工作了，这个PR，我们提交了很多条commit。  &lt;br /&gt;
6.将new分支上的commit，rebase成1条commit到你的master分支，等待merge。  &lt;br /&gt;
在PR被merge后，你的fork分支会落后官方分支，接下来要更新你的fork分支。&lt;br /&gt;
这时我们需要有一个新的merge分支用来merge新的commit，这个merge分支建立在你的master分支上。&lt;br /&gt;
7.点击github上面的compare，比较你的merge分支和官方master分支，将官方master分支上新的commit以PR的形式加到你的merge分支上。&lt;br /&gt;
9.将你merge分支上面的commit以rebase的形式放到你的master分支上。&lt;br /&gt;
10.删除你的merge分支和new分支。&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Git" /><summary type="html">长期更新使用Git和Github工作的内容。 案例展示 PR工作流程 场景描述 第一个场景是大家最常遇到的。 先从开源项目那边fork过来，然后clone到本地，准备工作，打算修改完代码再push回去，提交PR。 工作流程 上面提到的流程听起来非常理想，但是对那些对Git没什么经验的人来说，有非常多的坑存在。 1.首先我们要时刻保持fork的分支的master分支是与官方的master分支一致。 2.然后在你本地的master分支上面新建一个new分支，然后在这个new分支上工作。 前两点很重要，很多人一开始就直接在master分支上面干活，后面会造成非常多的麻烦。 3.在new分支上干活。 4.和远程的new分支同步。 5.在Github上面，你的fork仓库里点击PR，提交PR到官方仓库。 假设现在我们已经完成工作了，这个PR，我们提交了很多条commit。 6.将new分支上的commit，rebase成1条commit到你的master分支，等待merge。 在PR被merge后，你的fork分支会落后官方分支，接下来要更新你的fork分支。 这时我们需要有一个新的merge分支用来merge新的commit，这个merge分支建立在你的master分支上。 7.点击github上面的compare，比较你的merge分支和官方master分支，将官方master分支上新的commit以PR的形式加到你的merge分支上。 9.将你merge分支上面的commit以rebase的形式放到你的master分支上。 10.删除你的merge分支和new分支。</summary></entry></feed>
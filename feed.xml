<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:1727/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:1727/" rel="alternate" type="text/html" /><updated>2019-04-16T23:09:04+08:00</updated><id>http://localhost:1727/feed.xml</id><title type="html">slongle</title><subtitle></subtitle><author><name>slongle</name><email>junchendeng@gmail.com</email></author><entry><title type="html">Last Time</title><link href="http://localhost:1727/2019/04/10/Last-Time.html" rel="alternate" type="text/html" title="Last Time" /><published>2019-04-10T00:00:00+08:00</published><updated>2019-04-10T00:00:00+08:00</updated><id>http://localhost:1727/2019/04/10/Last%20Time</id><content type="html" xml:base="http://localhost:1727/2019/04/10/Last-Time.html">&lt;h2 id=&quot;topcoder&quot;&gt;Topcoder&lt;/h2&gt;

&lt;h3 id=&quot;srm-754&quot;&gt;SRM 754&lt;/h3&gt;
&lt;h4 id=&quot;medium&quot;&gt;Medium&lt;/h4&gt;
&lt;p&gt;题意 : 给定投影等价类数，构造一组点集方案。&lt;br /&gt;
题解 : 两个点有两个等价类，对于一个点集，$n^2$条直线去重后的个数为等价类数。构造两列点即可。&lt;/p&gt;
&lt;h4 id=&quot;hard&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 给定$4$连通块大小和$8$连通块大小，返回构造结果。&lt;br /&gt;
题解 : $8$连通块是由若干$4$连通块组合起来，状压DP一下，DP出一组解。然后按行构造即可。&lt;/p&gt;

&lt;h3 id=&quot;srm-753&quot;&gt;SRM 753&lt;/h3&gt;
&lt;h4 id=&quot;hard-1&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 给定一个序列，区间询问去掉一个数后的最大异或和。&lt;br /&gt;
题解 : 可持久化Trie树，区间异或和在区间的Trie树上异或出最大值。&lt;/p&gt;

&lt;h3 id=&quot;2019-humblefool-cup-prelims&quot;&gt;2019 Humblefool Cup Prelims&lt;/h3&gt;
&lt;h4 id=&quot;hard-2&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 定义相邻的两个质数为只有一个数位不同，且长度相同。询问两个质数可以到达。&lt;br /&gt;
题解 : 质数非常连通，预处理之后会发现，只有$4$个块，$2$个是孤点，还有$1$个是大小为$2$的块，剩下的点全部联通。&lt;/p&gt;

&lt;h3 id=&quot;srm-752&quot;&gt;SRM 752&lt;/h3&gt;
&lt;h4 id=&quot;hard-3&quot;&gt;Hard&lt;/h4&gt;
&lt;p&gt;题意 : 有$n$个硬币在桌子上，有$1$个硬币在手里，每次抛硬币，正面的话桌面上加$1$个硬币，手里留$1$个硬币，如果桌上有$2N$个硬币则游戏结束。反面的话，从桌上硬币拿走手里的硬币数个放到手里，如果桌上拿空则游戏结束。输出期望场数。&lt;br /&gt;
题解 : 转移显然有环，但是由于正面的特殊性，定义$f[i]$表示手里$1$个硬币，桌上$i$个硬币的期望场数。转移方程$f[i]=(f[i+1]+1)*0.5+(f[i]+2)*0.5^2+(f[i-2]+3)*0.5^3+\cdots$。可以发现转移有后效性，但是我们可以将$f[i+1]$去除后效性。&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Algorithm" /><summary type="html">Topcoder SRM 754 Medium 题意 : 给定投影等价类数，构造一组点集方案。 题解 : 两个点有两个等价类，对于一个点集，$n^2$条直线去重后的个数为等价类数。构造两列点即可。 Hard 题意 : 给定$4$连通块大小和$8$连通块大小，返回构造结果。 题解 : $8$连通块是由若干$4$连通块组合起来，状压DP一下，DP出一组解。然后按行构造即可。 SRM 753 Hard 题意 : 给定一个序列，区间询问去掉一个数后的最大异或和。 题解 : 可持久化Trie树，区间异或和在区间的Trie树上异或出最大值。 2019 Humblefool Cup Prelims Hard 题意 : 定义相邻的两个质数为只有一个数位不同，且长度相同。询问两个质数可以到达。 题解 : 质数非常连通，预处理之后会发现，只有$4$个块，$2$个是孤点，还有$1$个是大小为$2$的块，剩下的点全部联通。 SRM 752 Hard 题意 : 有$n$个硬币在桌子上，有$1$个硬币在手里，每次抛硬币，正面的话桌面上加$1$个硬币，手里留$1$个硬币，如果桌上有$2N$个硬币则游戏结束。反面的话，从桌上硬币拿走手里的硬币数个放到手里，如果桌上拿空则游戏结束。输出期望场数。 题解 : 转移显然有环，但是由于正面的特殊性，定义$f[i]$表示手里$1$个硬币，桌上$i$个硬币的期望场数。转移方程$f[i]=(f[i+1]+1)*0.5+(f[i]+2)*0.5^2+(f[i-2]+3)*0.5^3+\cdots$。可以发现转移有后效性，但是我们可以将$f[i+1]$去除后效性。</summary></entry><entry><title type="html">Work for Open Source Community Using Git</title><link href="http://localhost:1727/2019/03/19/Work-for-Open-Source-Community-Using-Git.html" rel="alternate" type="text/html" title="Work for Open Source Community Using Git" /><published>2019-03-19T00:00:00+08:00</published><updated>2019-03-19T00:00:00+08:00</updated><id>http://localhost:1727/2019/03/19/Work%20for%20Open%20Source%20Community%20Using%20Git</id><content type="html" xml:base="http://localhost:1727/2019/03/19/Work-for-Open-Source-Community-Using-Git.html">&lt;p&gt;长期更新使用Git和Github工作的内容。&lt;/p&gt;

&lt;h2 id=&quot;案例展示&quot;&gt;案例展示&lt;/h2&gt;
&lt;h3 id=&quot;pr工作流程&quot;&gt;PR工作流程&lt;/h3&gt;
&lt;h4 id=&quot;场景描述&quot;&gt;场景描述&lt;/h4&gt;
&lt;p&gt;第一个场景是大家最常遇到的。 &lt;br /&gt;
先从开源项目那边fork过来，然后clone到本地，准备工作，打算修改完代码再push回去，提交PR。&lt;/p&gt;
&lt;h4 id=&quot;工作流程&quot;&gt;工作流程&lt;/h4&gt;
&lt;p&gt;上面提到的流程听起来非常理想，但是对那些对Git没什么经验的人来说，有非常多的坑存在。&lt;br /&gt;
1.首先我们要时刻保持fork的分支的master分支是与官方的master分支一致。&lt;br /&gt;
2.然后在你本地的master分支上面新建一个new分支，然后在这个new分支上工作。&lt;br /&gt;
前两点很重要，很多人一开始就直接在master分支上面干活，后面会造成非常多的麻烦。&lt;br /&gt;
3.在new分支上干活。&lt;br /&gt;
4.和远程的new分支同步。&lt;br /&gt;
5.在Github上面，你的fork仓库里点击PR，提交PR到官方仓库。&lt;br /&gt;
假设现在我们已经完成工作了，这个PR，我们提交了很多条commit。  &lt;br /&gt;
6.将new分支上的commit，rebase成1条commit到你的master分支，等待merge。  &lt;br /&gt;
在PR被merge后，你的fork分支会落后官方分支，接下来要更新你的fork分支。&lt;br /&gt;
这时我们需要有一个新的merge分支用来merge新的commit，这个merge分支建立在你的master分支上。&lt;br /&gt;
7.点击github上面的compare，比较你的merge分支和官方master分支，将官方master分支上新的commit以PR的形式加到你的merge分支上。&lt;br /&gt;
9.将你merge分支上面的commit以rebase的形式放到你的master分支上。&lt;br /&gt;
10.删除你的merge分支和new分支。&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Git" /><summary type="html">长期更新使用Git和Github工作的内容。 案例展示 PR工作流程 场景描述 第一个场景是大家最常遇到的。 先从开源项目那边fork过来，然后clone到本地，准备工作，打算修改完代码再push回去，提交PR。 工作流程 上面提到的流程听起来非常理想，但是对那些对Git没什么经验的人来说，有非常多的坑存在。 1.首先我们要时刻保持fork的分支的master分支是与官方的master分支一致。 2.然后在你本地的master分支上面新建一个new分支，然后在这个new分支上工作。 前两点很重要，很多人一开始就直接在master分支上面干活，后面会造成非常多的麻烦。 3.在new分支上干活。 4.和远程的new分支同步。 5.在Github上面，你的fork仓库里点击PR，提交PR到官方仓库。 假设现在我们已经完成工作了，这个PR，我们提交了很多条commit。 6.将new分支上的commit，rebase成1条commit到你的master分支，等待merge。 在PR被merge后，你的fork分支会落后官方分支，接下来要更新你的fork分支。 这时我们需要有一个新的merge分支用来merge新的commit，这个merge分支建立在你的master分支上。 7.点击github上面的compare，比较你的merge分支和官方master分支，将官方master分支上新的commit以PR的形式加到你的merge分支上。 9.将你merge分支上面的commit以rebase的形式放到你的master分支上。 10.删除你的merge分支和new分支。</summary></entry></feed>
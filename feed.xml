<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:3798/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:3798/" rel="alternate" type="text/html" /><updated>2020-09-06T21:46:28+08:00</updated><id>http://localhost:3798/feed.xml</id><title type="html">slongle</title><subtitle></subtitle><author><name>slongle</name><email>junchendeng@gmail.com</email></author><entry><title type="html">Volume Rendering:Basic (part 1 of n)</title><link href="http://localhost:3798/2020/05/12/Volume-Rendering.html" rel="alternate" type="text/html" title="Volume Rendering:Basic (part 1 of n)" /><published>2020-05-12T00:00:00+08:00</published><updated>2020-05-12T00:00:00+08:00</updated><id>http://localhost:3798/2020/05/12/Volume%20Rendering</id><content type="html" xml:base="http://localhost:3798/2020/05/12/Volume-Rendering.html">&lt;h2 id=&quot;volume-rendering-equation&quot;&gt;Volume Rendering Equation&lt;/h2&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;L(x,\omega)=\int_{0}^{dist}T(x,y)[\mu_{a}(y)L_{e}(y,\omega)+\mu_{s}(y)L_{s}(y,\omega)]dt+T(x,z)L(z,\omega)&lt;/script&gt;&lt;br /&gt;
Here, $y=x+\omega\cdot t$, $T(x,y)=e^{-\int_{x}^{y}\mu_{t}(z)dz}$(Beer Lambert Law), $L_{s}(y, \omega)=\int_{S^2}f_{p}(\omega, \omega_i)L(y,\omega_i)d\omega_i$&lt;/p&gt;

&lt;p&gt;##&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Computer-Graphics" /><summary type="html">Volume Rendering Equation Here, $y=x+\omega\cdot t$, $T(x,y)=e^{-\int_{x}^{y}\mu_{t}(z)dz}$(Beer Lambert Law), $L_{s}(y, \omega)=\int_{S^2}f_{p}(\omega, \omega_i)L(y,\omega_i)d\omega_i$ ##</summary></entry><entry><title type="html">Atcoder选做</title><link href="http://localhost:3798/2019/09/17/Atcoder%E9%80%89%E5%81%9A.html" rel="alternate" type="text/html" title="Atcoder选做" /><published>2019-09-17T00:00:00+08:00</published><updated>2019-09-17T00:00:00+08:00</updated><id>http://localhost:3798/2019/09/17/Atcoder%E9%80%89%E5%81%9A</id><content type="html" xml:base="http://localhost:3798/2019/09/17/Atcoder%E9%80%89%E5%81%9A.html">&lt;h2 id=&quot;agc&quot;&gt;AGC&lt;/h2&gt;
&lt;p&gt;AGC补完计划:1/37&lt;/p&gt;
&lt;h3 id=&quot;agc001&quot;&gt;AGC001&lt;/h3&gt;
&lt;h4 id=&quot;c---shorten-diameter&quot;&gt;C - Shorten Diameter&lt;/h4&gt;
&lt;p&gt;题意:给定一棵$n$个点的树，每次删掉一个叶子结点，询问最少删除几次，使得最后得到的树的直径小于等于$m$。$n,m\le 2000$。&lt;br /&gt;
题解:对于一棵树，当它的直径为偶数时，它的中心是一个点，否则是一条边。如果我们想删除一些点得到一棵直径小于等于$m$的树，我们把距离中心大于$\frac{n}{2}$的点都删掉即可。所以枚举中心然后dfs一遍得到深度即可。&lt;br /&gt;
复杂度$O(n^2)$&lt;/p&gt;
&lt;h4 id=&quot;d---arrays-and-palindrome&quot;&gt;D - Arrays and Palindrome&lt;/h4&gt;
&lt;p&gt;题意:给定一个$A$序列，让你重排这个序列，并构造另一个序列$B$。&lt;br /&gt;
满足:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$\sum A_i=\sum B_i$&lt;/li&gt;
  &lt;li&gt;对于一个字符串$\text{S}$，如果$S_{1,A_1},S_{A_1+1,A_1+A_2},\cdots,S_{1,B_1},S_{B_1+1,B_1+B_2},\cdots$都为回文串，那么使得$\forall i,j,A_i=A_j$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;题解:当奇数个数大于$2$时，没有解。这样两个奇数块放在两端，将中间的偶数块用长度$-1$的$B$回文来连接。&lt;/p&gt;
&lt;h4 id=&quot;e---bbq-hard&quot;&gt;E - BBQ Hard&lt;/h4&gt;
&lt;p&gt;题意:求$\sum\sum C_{a_i+b_i+a_j+b_j}^{a_i+a_j}$。$n\le 200000,a_i,b_i\le 2000$。&lt;br /&gt;
题解:考虑$C_{a}^{b}$的组合意义是从$(0,0)$点走到$(a,b)$的方案数&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Algorithm" /><summary type="html">AGC AGC补完计划:1/37 AGC001 C - Shorten Diameter 题意:给定一棵$n$个点的树，每次删掉一个叶子结点，询问最少删除几次，使得最后得到的树的直径小于等于$m$。$n,m\le 2000$。 题解:对于一棵树，当它的直径为偶数时，它的中心是一个点，否则是一条边。如果我们想删除一些点得到一棵直径小于等于$m$的树，我们把距离中心大于$\frac{n}{2}$的点都删掉即可。所以枚举中心然后dfs一遍得到深度即可。 复杂度$O(n^2)$ D - Arrays and Palindrome 题意:给定一个$A$序列，让你重排这个序列，并构造另一个序列$B$。 满足: $\sum A_i=\sum B_i$ 对于一个字符串$\text{S}$，如果$S_{1,A_1},S_{A_1+1,A_1+A_2},\cdots,S_{1,B_1},S_{B_1+1,B_1+B_2},\cdots$都为回文串，那么使得$\forall i,j,A_i=A_j$ 题解:当奇数个数大于$2$时，没有解。这样两个奇数块放在两端，将中间的偶数块用长度$-1$的$B$回文来连接。 E - BBQ Hard 题意:求$\sum\sum C_{a_i+b_i+a_j+b_j}^{a_i+a_j}$。$n\le 200000,a_i,b_i\le 2000$。 题解:考虑$C_{a}^{b}$的组合意义是从$(0,0)$点走到$(a,b)$的方案数</summary></entry><entry><title type="html">Camke practice</title><link href="http://localhost:3798/2019/09/03/Camke-Practice.html" rel="alternate" type="text/html" title="Camke practice" /><published>2019-09-03T00:00:00+08:00</published><updated>2019-09-03T00:00:00+08:00</updated><id>http://localhost:3798/2019/09/03/Camke%20Practice</id><content type="html" xml:base="http://localhost:3798/2019/09/03/Camke-Practice.html">&lt;h2 id=&quot;cmake-practice&quot;&gt;Cmake Practice&lt;/h2&gt;

&lt;h3 id=&quot;basic-usage&quot;&gt;Basic Usage&lt;/h3&gt;

&lt;h3 id=&quot;third-party&quot;&gt;Third-Party&lt;/h3&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><summary type="html">Cmake Practice Basic Usage Third-Party</summary></entry><entry><title type="html">Software Construction之JVM</title><link href="http://localhost:3798/2019/06/23/Software-Construction-JVM.html" rel="alternate" type="text/html" title="Software Construction之JVM" /><published>2019-06-23T00:00:00+08:00</published><updated>2019-06-23T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/23/Software%20Construction%20JVM</id><content type="html" xml:base="http://localhost:3798/2019/06/23/Software-Construction-JVM.html">&lt;h3 id=&quot;memory&quot;&gt;Memory&lt;/h3&gt;
&lt;p&gt;Stack：所有的局部的primitive和ref变量 &lt;br /&gt;
Heap：所有的Object(局部的Object也是在Heap里，但局部的ref是stack) &lt;br /&gt;
Heap中有Method Area(Metaspace)：类信息，常量，静态变量&lt;/p&gt;
&lt;h3 id=&quot;gc&quot;&gt;GC&lt;/h3&gt;
&lt;h4 id=&quot;mark-sweep&quot;&gt;Mark-Sweep&lt;/h4&gt;
&lt;p&gt;标记是否存活，释放死亡的空间&lt;/p&gt;
&lt;h4 id=&quot;mark-compact&quot;&gt;Mark-Compact&lt;/h4&gt;
&lt;p&gt;标记是否存活，释放死亡的空间，然后碎片整理&lt;/p&gt;
&lt;h4 id=&quot;copy&quot;&gt;Copy&lt;/h4&gt;
&lt;p&gt;标记是否存活，将活的整个复制到另一个空间&lt;/p&gt;
&lt;h4 id=&quot;具体gc&quot;&gt;具体GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/HsRbRbfh/0058.png&quot; alt=&quot;&quot; /&gt;
年轻代：copy算法执行GC&lt;br /&gt;
老年代：Mark-Sweep或Mark-Compact算法执行GC&lt;br /&gt;
当某个区域满时，执行GC&lt;br /&gt;
年轻代执行minor GC，时间较短&lt;br /&gt;
年轻代中经历多轮minor GC后，copy到老年代&lt;br /&gt;
老年代满了之后，老年代执行full GC&lt;/p&gt;
&lt;h4 id=&quot;设置各代空间大小&quot;&gt;设置各代空间大小&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/9QHry13C/0059.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;jvm命令&quot;&gt;JVM命令&lt;/h3&gt;
&lt;h4 id=&quot;jmap&quot;&gt;jmap&lt;/h4&gt;
&lt;p&gt;Heap Configuration:&lt;br /&gt;
   MinHeapFreeRatio         = 0    //JVM最小空闲比率 jvm heap 在使用率小于 n 时 ,heap 进行收缩&lt;br /&gt;
   MaxHeapFreeRatio         = 100  //JVM最大空闲比率 jvm heap 在使用率大于 n 时 ,heap 进行扩张 &lt;br /&gt;
   MaxHeapSize              = 2095054848 (1998.0MB) //JVM堆的最大大小&lt;br /&gt;
   NewSize                  = 44040192 (42.0MB) //JVM新生代的默认大小&lt;br /&gt;
   MaxNewSize               = 698351616 (666.0MB) //JVM新生代的最大大小&lt;br /&gt;
   OldSize                  = 88080384 (84.0MB) //JVM老生代的默认大小 &lt;br /&gt;
   NewRatio                 = 2 //新生代：老生代（的大小）=1:2&lt;br /&gt;
   SurvivorRatio            = 8 //survivor:eden = 1:8,即survivor space是新生代大小的1/(8+2)[因为有两个survivor区域]&lt;br /&gt;
   MetaspaceSize            = 21807104 (20.796875MB) //元空间的默认大小，超过此值就会触发Full GC&lt;br /&gt;
   CompressedClassSpaceSize = 1073741824 (1024.0MB) //类指针压缩空间的默认大小&lt;br /&gt;
   MaxMetaspaceSize         = 17592186044415 MB //元空间的最大大小&lt;br /&gt;
   G1HeapRegionSize         = 0 (0.0MB) //使用G1垃圾收集器的时候，堆被分割的大小&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">Memory Stack：所有的局部的primitive和ref变量 Heap：所有的Object(局部的Object也是在Heap里，但局部的ref是stack) Heap中有Method Area(Metaspace)：类信息，常量，静态变量 GC Mark-Sweep 标记是否存活，释放死亡的空间 Mark-Compact 标记是否存活，释放死亡的空间，然后碎片整理 Copy 标记是否存活，将活的整个复制到另一个空间 具体GC 年轻代：copy算法执行GC 老年代：Mark-Sweep或Mark-Compact算法执行GC 当某个区域满时，执行GC 年轻代执行minor GC，时间较短 年轻代中经历多轮minor GC后，copy到老年代 老年代满了之后，老年代执行full GC 设置各代空间大小 JVM命令 jmap Heap Configuration: MinHeapFreeRatio = 0    //JVM最小空闲比率 jvm heap 在使用率小于 n 时 ,heap 进行收缩 MaxHeapFreeRatio = 100  //JVM最大空闲比率 jvm heap 在使用率大于 n 时 ,heap 进行扩张  MaxHeapSize = 2095054848 (1998.0MB) //JVM堆的最大大小 NewSize = 44040192 (42.0MB) //JVM新生代的默认大小 MaxNewSize = 698351616 (666.0MB) //JVM新生代的最大大小 OldSize = 88080384 (84.0MB) //JVM老生代的默认大小  NewRatio = 2 //新生代：老生代（的大小）=1:2 SurvivorRatio = 8 //survivor:eden = 1:8,即survivor space是新生代大小的1/(8+2)[因为有两个survivor区域] MetaspaceSize = 21807104 (20.796875MB) //元空间的默认大小，超过此值就会触发Full GC CompressedClassSpaceSize = 1073741824 (1024.0MB) //类指针压缩空间的默认大小 MaxMetaspaceSize = 17592186044415 MB //元空间的最大大小 G1HeapRegionSize = 0 (0.0MB) //使用G1垃圾收集器的时候，堆被分割的大小</summary></entry><entry><title type="html">Software Construction之Others</title><link href="http://localhost:3798/2019/06/23/Software-Construction-Others.html" rel="alternate" type="text/html" title="Software Construction之Others" /><published>2019-06-23T00:00:00+08:00</published><updated>2019-06-23T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/23/Software%20Construction%20Others</id><content type="html" xml:base="http://localhost:3798/2019/06/23/Software-Construction-Others.html">&lt;h3 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;$*$:{0,}&lt;/li&gt;
  &lt;li&gt;$+$:{1,}&lt;/li&gt;
  &lt;li&gt;$?$:{0,1}&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;:或&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;^:取补集&lt;/li&gt;
  &lt;li&gt;[bc]等价于[b-c]
    &lt;h3 id=&quot;lsp&quot;&gt;LSP&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;子类型可以增加方法，但不可删&lt;/li&gt;
  &lt;li&gt;子类型需要实现抽象类型中的所有未实现方法&lt;/li&gt;
  &lt;li&gt;子类型中重写的方法必须有相同或子类型的返回值或者符合 co-variance 的参数&lt;/li&gt;
  &lt;li&gt;子类型中重写的方法必须使用同样类型的参数或者符合 contra-variance 的参数&lt;/li&gt;
  &lt;li&gt;子类型中重写的方法不能抛出额外的异常&lt;/li&gt;
  &lt;li&gt;更强的不变量&lt;/li&gt;
  &lt;li&gt;更弱的前置条件&lt;/li&gt;
  &lt;li&gt;更强的后置条件
    &lt;h3 id=&quot;软件构造基础&quot;&gt;软件构造基础&lt;/h3&gt;
    &lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/Y2g37nxw/0060.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;h3 id=&quot;版本控制&quot;&gt;版本控制&lt;/h3&gt;
    &lt;p&gt;SCM : 软件配置管理&lt;br /&gt;
VCS : 版本控制  &lt;br /&gt;
SCI : 软件配置项(软件中发生改变的基本单元，例如:文件)&lt;br /&gt;
CMDB : 配置管理数据库(存储软件的各配置项随时间发生变化的信息)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">正则表达式 $*$:{0,} $+$:{1,} $?$:{0,1} :或 ^:取补集 [bc]等价于[b-c] LSP 子类型可以增加方法，但不可删 子类型需要实现抽象类型中的所有未实现方法 子类型中重写的方法必须有相同或子类型的返回值或者符合 co-variance 的参数 子类型中重写的方法必须使用同样类型的参数或者符合 contra-variance 的参数 子类型中重写的方法不能抛出额外的异常 更强的不变量 更弱的前置条件 更强的后置条件 软件构造基础 版本控制 SCM : 软件配置管理 VCS : 版本控制 SCI : 软件配置项(软件中发生改变的基本单元，例如:文件) CMDB : 配置管理数据库(存储软件的各配置项随时间发生变化的信息)</summary></entry><entry><title type="html">Software Construction之Design Pattern</title><link href="http://localhost:3798/2019/06/22/Software-Construction-Design-Pattern.html" rel="alternate" type="text/html" title="Software Construction之Design Pattern" /><published>2019-06-22T00:00:00+08:00</published><updated>2019-06-22T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/22/Software%20Construction%20Design%20Pattern</id><content type="html" xml:base="http://localhost:3798/2019/06/22/Software-Construction-Design-Pattern.html">&lt;h2 id=&quot;creational-patterns&quot;&gt;Creational patterns&lt;/h2&gt;
&lt;h3 id=&quot;工厂方法模式factory-method-pattern&quot;&gt;工厂方法模式(Factory Method pattern)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/PqH1yTw3/0048.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;抽象工厂模式abstract-factory&quot;&gt;抽象工厂模式(Abstract Factory)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/7Z0gSffJ/0049.png&quot; alt=&quot;&quot; /&gt;
抽象工厂模式和工厂方法模式的区别在于，抽象工厂模式的工厂会创造一个产品的多个组件，而工厂方法模式直接创造一个产品。&lt;/p&gt;
&lt;h3 id=&quot;构造器模式builder&quot;&gt;构造器模式(Builder)&lt;/h3&gt;
&lt;p&gt;Builder抽象类的子类直接build一种产品。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/yxDRxNMd/0050.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;structural-patterns&quot;&gt;Structural patterns&lt;/h2&gt;
&lt;h3 id=&quot;适配器模式adapter&quot;&gt;适配器模式(Adapter)&lt;/h3&gt;
&lt;p&gt;封装为Client方便的形式。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/y6tr73Rw/0042.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;装饰器模式decorator&quot;&gt;装饰器模式(Decorator)&lt;/h3&gt;
&lt;p&gt;将类和类之间嵌套起来，使得到的类包含有之前类的属性和自己的属性。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/HsMvnW4j/0043.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://i.postimg.cc/dVKHyM46/0044.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;外观模式facade&quot;&gt;外观模式(Facade)&lt;/h3&gt;
&lt;p&gt;也是为了Client的方便来封装。&lt;br /&gt;
与Adapter模式不同的是，Facade是将一些过程封装为一个过程，而Adapter是将参数封装。&lt;/p&gt;
&lt;h3 id=&quot;桥接模式bridge&quot;&gt;桥接模式(Bridge)&lt;/h3&gt;
&lt;p&gt;通过委派和继承来实现复杂操作。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/SxhGT60f/0051.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;代理模式proxy&quot;&gt;代理模式(Proxy)&lt;/h3&gt;
&lt;p&gt;为了隔离Client的访问，设置一个代理。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/k5jFgL2T/0052.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;组合模式composite&quot;&gt;组合模式(Composite)&lt;/h3&gt;
&lt;p&gt;类似于装饰器模式，区别在于每个类内部可以有多个其他类的实例而不是只有一个。&lt;/p&gt;
&lt;h2 id=&quot;behavioral-patterns&quot;&gt;Behavioral patterns&lt;/h2&gt;
&lt;h3 id=&quot;策略模式strategy&quot;&gt;策略模式(Strategy)&lt;/h3&gt;
&lt;p&gt;对于策略进行抽象，抽象为Strategy类/接口，然后Strategy中有一个work函数，在子类中实现这个work函数。&lt;br /&gt;
这样只需要切换传入的Strategy是哪个子类就可以了。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/k4VFHwTD/0045.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;模板模式template-method&quot;&gt;模板模式(Template Method)&lt;/h3&gt;
&lt;p&gt;当做事情的步骤一样，但具体方法不同。&lt;br /&gt;
具体来说是，当某个过程work都是由step1(),step2(),step3()这种顺序执行，即&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;step1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;step2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;step3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;但是step1(),step2()可能对于不同的事情具体操作不同，要写成不同的类。&lt;br /&gt;
那么可以在抽象类/接口中实现work()如上，并定义函数step1(),step2()…，然后在继承这个类的不同的类中Override这些step()方法。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/vHyf7Qw4/0046.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;迭代器模式iterator&quot;&gt;迭代器模式(Iterator)&lt;/h3&gt;
&lt;p&gt;对于遍历ADT中的元素，使用Iterator来遍历，不用用户自己去决定怎么遍历。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/y8bDGKtX/0047.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;观察者模式observer&quot;&gt;观察者模式(Observer)&lt;/h3&gt;
&lt;p&gt;有一个被观察者A和很多观察者B1,B2,…。&lt;br /&gt;
Bi先到A那里注册，当A有事件要发布时，A会更新所有观察者的状态。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/2jLFCcrx/0053.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;访问者模式visitor&quot;&gt;访问者模式(Visitor)&lt;/h3&gt;
&lt;p&gt;以类与类的交互形式完成操作。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/4dDcKGsQ/0054.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;中介模式mediator&quot;&gt;中介模式(Mediator)&lt;/h3&gt;
&lt;p&gt;本质上是A与B的交互，现在转化为A与B的中介的交互。&lt;br /&gt;
通过设置中介，使得整个结构耦合度降低。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/bYnb7Z9C/0055.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;命令模式command&quot;&gt;命令模式(Command)&lt;/h3&gt;
&lt;p&gt;通过委派的形式，将命令作用的实例保存在命令里，执行命令即可。&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/ZKFNqXg6/0056.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;备忘录模式memento-pattern&quot;&gt;备忘录模式(Memento Pattern)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/L8tx2ykW/0057.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">Creational patterns 工厂方法模式(Factory Method pattern) 抽象工厂模式(Abstract Factory) 抽象工厂模式和工厂方法模式的区别在于，抽象工厂模式的工厂会创造一个产品的多个组件，而工厂方法模式直接创造一个产品。 构造器模式(Builder) Builder抽象类的子类直接build一种产品。 Structural patterns 适配器模式(Adapter) 封装为Client方便的形式。 装饰器模式(Decorator) 将类和类之间嵌套起来，使得到的类包含有之前类的属性和自己的属性。 外观模式(Facade) 也是为了Client的方便来封装。 与Adapter模式不同的是，Facade是将一些过程封装为一个过程，而Adapter是将参数封装。 桥接模式(Bridge) 通过委派和继承来实现复杂操作。 代理模式(Proxy) 为了隔离Client的访问，设置一个代理。 组合模式(Composite) 类似于装饰器模式，区别在于每个类内部可以有多个其他类的实例而不是只有一个。 Behavioral patterns 策略模式(Strategy) 对于策略进行抽象，抽象为Strategy类/接口，然后Strategy中有一个work函数，在子类中实现这个work函数。 这样只需要切换传入的Strategy是哪个子类就可以了。 模板模式(Template Method) 当做事情的步骤一样，但具体方法不同。 具体来说是，当某个过程work都是由step1(),step2(),step3()这种顺序执行，即 public void work(){ step1(); step2(); step3(); } 但是step1(),step2()可能对于不同的事情具体操作不同，要写成不同的类。 那么可以在抽象类/接口中实现work()如上，并定义函数step1(),step2()…，然后在继承这个类的不同的类中Override这些step()方法。 迭代器模式(Iterator) 对于遍历ADT中的元素，使用Iterator来遍历，不用用户自己去决定怎么遍历。 Iterator iterator = adt.iterator(); while (iterator.hasNext()) { Integer item = (Integer) iterator.next(); } 观察者模式(Observer) 有一个被观察者A和很多观察者B1,B2,…。 Bi先到A那里注册，当A有事件要发布时，A会更新所有观察者的状态。 访问者模式(Visitor) 以类与类的交互形式完成操作。 中介模式(Mediator) 本质上是A与B的交互，现在转化为A与B的中介的交互。 通过设置中介，使得整个结构耦合度降低。 命令模式(Command) 通过委派的形式，将命令作用的实例保存在命令里，执行命令即可。 备忘录模式(Memento Pattern)</summary></entry><entry><title type="html">Software Construction之Test and Exception</title><link href="http://localhost:3798/2019/06/22/Software-Construction-Test-and-Exception.html" rel="alternate" type="text/html" title="Software Construction之Test and Exception" /><published>2019-06-22T00:00:00+08:00</published><updated>2019-06-22T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/22/Software%20Construction%20Test%20and%20Exception</id><content type="html" xml:base="http://localhost:3798/2019/06/22/Software-Construction-Test-and-Exception.html">&lt;h2 id=&quot;exception&quot;&gt;Exception&lt;/h2&gt;
&lt;h3 id=&quot;checked-and-unchecked-exception&quot;&gt;checked and unchecked exception&lt;/h3&gt;
&lt;p&gt;checked exception:要handle的exception，如：找不到xxx&lt;br /&gt;
unchecked exception:不handle，直接退出的exception，如&lt;code class=&quot;highlighter-rouge&quot;&gt;Null­Pointer­Exception&lt;/code&gt;&lt;br /&gt;
不用handle的是unchecked，用handle的是checked&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/g2PWRnTQ/0041.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
Exception类是checked exception&lt;br /&gt;
RuntimeException和Error类是unchecked exception&lt;/p&gt;
&lt;h3 id=&quot;javadoc&quot;&gt;Javadoc&lt;/h3&gt;
&lt;p&gt;checked exception需要注释，unchecked exception和error不需要&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * @throws NotPerfectSquareException if x it not a perfect square
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;integerSquareRoot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;定义和抛出异常&quot;&gt;定义和抛出异常&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NotPerfectSquareException&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**
 * @throws NotPerfectSquareException if x it not a perfect square
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;integerSquareRoot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NotPerfectSquareException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;exception的执行&quot;&gt;Exception的执行&lt;/h3&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;无论怎么执行try和catch，最后都会执行final中的内容&lt;br /&gt;
当A结束时出现异常，如果被捕获就执行C,D，如果没被捕获直接执行D然后退出&lt;/p&gt;
&lt;h2 id=&quot;test&quot;&gt;Test&lt;/h2&gt;
&lt;h3 id=&quot;test-strategy&quot;&gt;Test Strategy&lt;/h3&gt;
&lt;h4 id=&quot;白盒测试&quot;&gt;白盒测试&lt;/h4&gt;
&lt;p&gt;针对代码执行路径设计测试，要求全覆盖&lt;/p&gt;
&lt;h4 id=&quot;黑盒测试&quot;&gt;黑盒测试&lt;/h4&gt;
&lt;p&gt;只考虑spec&lt;/p&gt;
&lt;h5 id=&quot;等价类划分&quot;&gt;等价类划分&lt;/h5&gt;
&lt;p&gt;正负，奇偶，整数非整数，具体某格式和非该格式，长度限制，数据上限&lt;/p&gt;
&lt;h5 id=&quot;考虑边界值&quot;&gt;考虑边界值&lt;/h5&gt;
&lt;p&gt;边界值及边界值附近&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * Testing Strategy
 * 
 * Partition the inputs as follow
 * text.length() : 0, 1, &amp;gt;1
 * start : 0, 1, 1&amp;lt;start&amp;lt;text.length(), text.length()-1, text.length()
 * text.length()-start : 0, 1, even&amp;gt;1, odd&amp;gt;1 
 * 
 * Include ... because ...
 *
 */&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;// cover text.length() = 0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//       start = text.length = 0         &lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Text&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testXXX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">Exception checked and unchecked exception checked exception:要handle的exception，如：找不到xxx unchecked exception:不handle，直接退出的exception，如Null­Pointer­Exception 不用handle的是unchecked，用handle的是checked Exception类是checked exception RuntimeException和Error类是unchecked exception Javadoc checked exception需要注释，unchecked exception和error不需要 /** * @throws NotPerfectSquareException if x it not a perfect square */ int integerSquareRoot(int x) throws NotPerfectSquareException{ ... } 定义和抛出异常 public class NotPerfectSquareException extends Exception { public NotPerfectSquareException() { super(); } public NotPerfectSquareException(String message) { super(message); } public NotPerfectSquareException(String message, Throwable cause) { super(message, cause); } public NotPerfectSquareException(Throwable cause) { super(cause); } } /** * @throws NotPerfectSquareException if x it not a perfect square */ int integerSquareRoot(int x) throws NotPerfectSquareException{ throws new NotPerfectSquareException(); } Exception的执行 try{ A; B; } catch(Exception1 e1){ C; } final{ D; } 无论怎么执行try和catch，最后都会执行final中的内容 当A结束时出现异常，如果被捕获就执行C,D，如果没被捕获直接执行D然后退出 Test Test Strategy 白盒测试 针对代码执行路径设计测试，要求全覆盖 黑盒测试 只考虑spec 等价类划分 正负，奇偶，整数非整数，具体某格式和非该格式，长度限制，数据上限 考虑边界值 边界值及边界值附近 /* * Testing Strategy * * Partition the inputs as follow * text.length() : 0, 1, &amp;gt;1 * start : 0, 1, 1&amp;lt;start&amp;lt;text.length(), text.length()-1, text.length() * text.length()-start : 0, 1, even&amp;gt;1, odd&amp;gt;1 * * Include ... because ... * */ // cover text.length() = 0 // start = text.length = 0 @Text public void testXXX(){ ... }</summary></entry><entry><title type="html">Software Construction之ADT</title><link href="http://localhost:3798/2019/06/21/Software-Construction-ADT.html" rel="alternate" type="text/html" title="Software Construction之ADT" /><published>2019-06-21T00:00:00+08:00</published><updated>2019-06-21T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/21/Software%20Construction%20ADT</id><content type="html" xml:base="http://localhost:3798/2019/06/21/Software-Construction-ADT.html">&lt;h3 id=&quot;mutable和immutable&quot;&gt;Mutable和Immutable&lt;/h3&gt;
&lt;p&gt;Primitive:int,Integer,String…为Immutable，在
stack中分配内存&lt;br /&gt;
Object:Immutable/Mutable，heap中分配内存
防御式拷贝&lt;/p&gt;

&lt;h3 id=&quot;check&quot;&gt;check&lt;/h3&gt;
&lt;p&gt;静态类型检查：可在编译阶段发现错误，是关于“类型”的检查，不考虑值&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;语法错误&lt;/li&gt;
  &lt;li&gt;类名/函数名错误&lt;/li&gt;
  &lt;li&gt;参数数目错误&lt;/li&gt;
  &lt;li&gt;参数类型错误&lt;/li&gt;
  &lt;li&gt;返回值类型错误
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// b cannot be resolved to a variable&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;---------------&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// The local variable b may not have been initialized&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;动态检查：关于“值”的检查&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;非法的参数值(int=int/0会error,double=int/double(0)等返回Infinity不会error)&lt;/li&gt;
  &lt;li&gt;非法的返回值&lt;/li&gt;
  &lt;li&gt;越界&lt;/li&gt;
  &lt;li&gt;空指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;snapshot-diagram&quot;&gt;Snapshot diagram&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;基本类型的值
&lt;img src=&quot;https://i.postimg.cc/tJKPLmtB/0036.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;对象类型的值
&lt;img src=&quot;https://i.postimg.cc/zGSWc7Lk/0037.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Immutable的值用双线椭圆
&lt;img src=&quot;https://i.postimg.cc/sgR7mq2X/0038.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;值的改变
&lt;img src=&quot;https://i.postimg.cc/ncmqvppg/0039.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;final值使用双线箭头
&lt;img src=&quot;https://i.postimg.cc/3rVg4d52/0040.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;exception&quot;&gt;Exception&lt;/h3&gt;
&lt;p&gt;checked exception:要handle的exception，如：找不到xxx&lt;br /&gt;
unchecked exception:不handle，直接退出的exception，如&lt;code class=&quot;highlighter-rouge&quot;&gt;Null­Pointer­Exception&lt;/code&gt;&lt;br /&gt;
不用handle的是unchecked，用handle的是checked&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/g2PWRnTQ/0041.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
Exception类是checked exception&lt;br /&gt;
RuntimeException和Error类是unchecked exception&lt;/p&gt;
&lt;h3 id=&quot;spec&quot;&gt;Spec&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;spec里不需要解释参数的类型&lt;/li&gt;
  &lt;li&gt;若spec:A&amp;gt;=spec:B，那么满足A的precondition&amp;lt;=B的precondition,且对于满足B的precondition来说，A的postcondition&amp;gt;=B的postcondition。&lt;br /&gt;
也就是更弱的precondition或更强的postcondition，意味着更少的实现方式，和更多的用户使用。&lt;br /&gt;
两个不可比较的spec也可能有交集。&lt;/li&gt;
  &lt;li&gt;好的spec应该是倾向于陈述性，而不是具体的实现。&lt;br /&gt;
好的spec应该既不强也不弱，强会给实现带来负担，弱会给client的使用带来限制。&lt;br /&gt;
好的spec应该是解耦的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;abstract-type&quot;&gt;Abstract type&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;区分Creator和Producer：A的Creater是用非A的参数来构造一个A并返回，A的Producer是用一个A来构造一个A并返回。&lt;/li&gt;
  &lt;li&gt;区分Creator/Producer和Observor：A的Observor是返回一个非A的对象，A的Creator/Producer是返回一个A的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spec和rep&quot;&gt;Spec和Rep&lt;/h3&gt;
&lt;p&gt;Spec包括函数名，包括类名。&lt;br /&gt;
Rep包括field和field的注释。&lt;/p&gt;
&lt;h3 id=&quot;representation-independence&quot;&gt;Representation independence&lt;/h3&gt;
&lt;p&gt;表示独立性：Client不需要考虑ADT中的具体实现。&lt;/p&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">Mutable和Immutable Primitive:int,Integer,String…为Immutable，在 stack中分配内存 Object:Immutable/Mutable，heap中分配内存 防御式拷贝 check 静态类型检查：可在编译阶段发现错误，是关于“类型”的检查，不考虑值 语法错误 类名/函数名错误 参数数目错误 参数类型错误 返回值类型错误 int a = 5; if (a &amp;gt; 10) { int b = 2; } else { int b = 4; } b *= 3; // b cannot be resolved to a variable --------------- int a = 5; int b; if (a &amp;gt; 10) { b = 1; } b *= 3; // The local variable b may not have been initialized 动态检查：关于“值”的检查 非法的参数值(int=int/0会error,double=int/double(0)等返回Infinity不会error) 非法的返回值 越界 空指针 Snapshot diagram 基本类型的值 对象类型的值 Immutable的值用双线椭圆 值的改变 final值使用双线箭头 Exception checked exception:要handle的exception，如：找不到xxx unchecked exception:不handle，直接退出的exception，如Null­Pointer­Exception 不用handle的是unchecked，用handle的是checked Exception类是checked exception RuntimeException和Error类是unchecked exception Spec spec里不需要解释参数的类型 若spec:A&amp;gt;=spec:B，那么满足A的precondition&amp;lt;=B的precondition,且对于满足B的precondition来说，A的postcondition&amp;gt;=B的postcondition。 也就是更弱的precondition或更强的postcondition，意味着更少的实现方式，和更多的用户使用。 两个不可比较的spec也可能有交集。 好的spec应该是倾向于陈述性，而不是具体的实现。 好的spec应该既不强也不弱，强会给实现带来负担，弱会给client的使用带来限制。 好的spec应该是解耦的。 Abstract type 区分Creator和Producer：A的Creater是用非A的参数来构造一个A并返回，A的Producer是用一个A来构造一个A并返回。 区分Creator/Producer和Observor：A的Observor是返回一个非A的对象，A的Creator/Producer是返回一个A的对象。 Spec和Rep Spec包括函数名，包括类名。 Rep包括field和field的注释。 Representation independence 表示独立性：Client不需要考虑ADT中的具体实现。</summary></entry><entry><title type="html">Software Construction之Thread</title><link href="http://localhost:3798/2019/06/20/Software-Construction-Thread.html" rel="alternate" type="text/html" title="Software Construction之Thread" /><published>2019-06-20T00:00:00+08:00</published><updated>2019-06-20T00:00:00+08:00</updated><id>http://localhost:3798/2019/06/20/Software%20Construction%20Thread</id><content type="html" xml:base="http://localhost:3798/2019/06/20/Software-Construction-Thread.html">&lt;h2 id=&quot;java中多线程的状态及转移&quot;&gt;Java中多线程的状态及转移&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/tTwXyz1x/0034.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadstart和threadrun的区别&quot;&gt;Thread.start()和Thread.run()的区别&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Thread.start()只能被调用一次，而Thread.run()可以被调用多次&lt;/li&gt;
  &lt;li&gt;Thread.start()是真正的多线程，在得到cpu的time slice时，开始执行run()方法；而Thread.run()只是一个函数，当Thread.run()被调用时，程序顺序执行Thread.run()的内容，执行结束后才会继续执行后面的内容
    &lt;h2 id=&quot;主动改变线程状态的方法&quot;&gt;主动改变线程状态的方法&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread.sleep()&lt;br /&gt;
注意，Thread.sleep()需要处理InterruptedException异常&lt;/li&gt;
  &lt;li&gt;Thread.interrupt()&lt;br /&gt;
注意，Thread.interrupted()只会在Thread.sleep()时或者使用Thread.interrupted()/Thread.currentThread().isInterrupted()时检测，否则即使外界调用Thread.interrupt()，线程仍然继续执行&lt;br /&gt;
举例来说，下面的代码不会停止，会一直输出”Running”
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Running&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;想要接收到interrupt信号需要下面这种写法&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Running&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;或者&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Running&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;thread-safe&quot;&gt;Thread Safe&lt;/h2&gt;
    &lt;h3 id=&quot;confinement&quot;&gt;Confinement&lt;/h3&gt;
    &lt;p&gt;线程之间不共享mutable数据(避免使用mutable的全局变量)&lt;/p&gt;
    &lt;h3 id=&quot;immutability&quot;&gt;Immutability&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;No mutator methods&lt;/li&gt;
  &lt;li&gt;All fields are private and final&lt;/li&gt;
  &lt;li&gt;No representation exposure&lt;/li&gt;
  &lt;li&gt;No mutation whatsoever of mutable objects in the rep not even beneficent mutation
    &lt;h3 id=&quot;threadsafe-data-types&quot;&gt;Threadsafe Data Types&lt;/h3&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;synchronizedMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;即使在线程安全的ADT上，使用 iterator也是不安全的&lt;/p&gt;
    &lt;h3 id=&quot;lock&quot;&gt;Lock&lt;/h3&gt;
    &lt;p&gt;使用synchronized
使用方法：&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;等价于&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h3 id=&quot;threadsafe-和-race-condition&quot;&gt;&lt;strong&gt;Threadsafe 和 race condition&lt;/strong&gt;&lt;/h3&gt;
    &lt;p&gt;&lt;strong&gt;注意：这是两个没有关系的词&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Threadsafe只保证在多线程的情况下，ADT依然满足ADT的spec&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Threadsafe的ADT依然会发生race condition&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;比如HashSet的Iterator，在多线程下不是ThreadSafe的，因为Iterator的spec要求在使用Iterator时，不能修改HashSet&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;但即便使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedMap&lt;/code&gt;，虽然get(),put()等操作是Threadsafe的，但Iterator仍然不是Threadsafe&lt;/strong&gt;&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;s:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;// not threadsafe, even if lst is a synchronized list wrapper&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;strong&gt;即使使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedMap&lt;/code&gt;，当两个Thread同时调用put()操作，是race condition&lt;/strong&gt;&lt;/p&gt;
    &lt;h2 id=&quot;锁&quot;&gt;锁&lt;/h2&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized (list) { ... }&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;只代表别人不能用list的锁&lt;/strong&gt;&lt;/p&gt;
    &lt;h3 id=&quot;死锁deadlock&quot;&gt;死锁(Deadlock)&lt;/h3&gt;
    &lt;p&gt;如下图所示，当T1进入锁定a，T2进入锁定b后，T1和T2进入死锁&lt;br /&gt;
&lt;img src=&quot;https://i.postimg.cc/kg4hzHJF/0035.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
如何判断死锁？&lt;br /&gt;
两个进程有T1和T2，锁的序列为S1和S2，取S1和S2的任意两个前缀P1和P2(P1∩P2为空)，以及相应的下一位N1和N2。&lt;br /&gt;
若N1$\in$P2且N2$\in$P1则N1和N2死锁。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Software-Construction" /><summary type="html">Java中多线程的状态及转移 Thread.start()和Thread.run()的区别 Thread.start()只能被调用一次，而Thread.run()可以被调用多次 Thread.start()是真正的多线程，在得到cpu的time slice时，开始执行run()方法；而Thread.run()只是一个函数，当Thread.run()被调用时，程序顺序执行Thread.run()的内容，执行结束后才会继续执行后面的内容 主动改变线程状态的方法 Thread.sleep() 注意，Thread.sleep()需要处理InterruptedException异常 Thread.interrupt() 注意，Thread.interrupted()只会在Thread.sleep()时或者使用Thread.interrupted()/Thread.currentThread().isInterrupted()时检测，否则即使外界调用Thread.interrupt()，线程仍然继续执行 举例来说，下面的代码不会停止，会一直输出”Running” Thread a=new Thread(new Runnable() { @Override public void run() { while(true){ System.out.println(&quot;Running&quot;); } } }); a.start(); a.interrupt(); 想要接收到interrupt信号需要下面这种写法 Thread a=new Thread(new Runnable() { @Override public void run() { while(!Thread.interrupted()){ System.out.println(&quot;Running&quot;); } } }); a.start(); a.interrupt(); 或者 Thread a = new Thread(new Runnable() { @Override public void run() { try { while (true) { System.out.println(&quot;Running&quot;); Thread.sleep(100); } } catch (InterruptedException ie){ } } }); a.start(); a.interrupt(); Thread Safe Confinement 线程之间不共享mutable数据(避免使用mutable的全局变量) Immutability No mutator methods All fields are private and final No representation exposure No mutation whatsoever of mutable objects in the rep not even beneficent mutation Threadsafe Data Types private static Map&amp;lt;Integer,Boolean&amp;gt; cache = Collections.synchronizedMap(new HashMap&amp;lt;&amp;gt;()); 即使在线程安全的ADT上，使用 iterator也是不安全的 Lock 使用synchronized 使用方法： public void foo(){ synchronized(this){ ... } } 等价于 public synchronized void foo(){ ... } Threadsafe 和 race condition 注意：这是两个没有关系的词 Threadsafe只保证在多线程的情况下，ADT依然满足ADT的spec Threadsafe的ADT依然会发生race condition 比如HashSet的Iterator，在多线程下不是ThreadSafe的，因为Iterator的spec要求在使用Iterator时，不能修改HashSet 但即便使用了Collections.synchronizedMap，虽然get(),put()等操作是Threadsafe的，但Iterator仍然不是Threadsafe for (String s: lst) { ... } // not threadsafe, even if lst is a synchronized list wrapper 即使使用了Collections.synchronizedMap，当两个Thread同时调用put()操作，是race condition 锁 synchronized (list) { ... } 只代表别人不能用list的锁 死锁(Deadlock) 如下图所示，当T1进入锁定a，T2进入锁定b后，T1和T2进入死锁 如何判断死锁？ 两个进程有T1和T2，锁的序列为S1和S2，取S1和S2的任意两个前缀P1和P2(P1∩P2为空)，以及相应的下一位N1和N2。 若N1$\in$P2且N2$\in$P1则N1和N2死锁。</summary></entry><entry><title type="html">Monte Carlo Methods for Volumetric Light Transport Simulation</title><link href="http://localhost:3798/2019/05/09/Monte-Carlo-Methods-for-Volumetric-Light-Transport-Simulation.html" rel="alternate" type="text/html" title="Monte Carlo Methods for Volumetric Light Transport Simulation" /><published>2019-05-09T00:00:00+08:00</published><updated>2019-05-09T00:00:00+08:00</updated><id>http://localhost:3798/2019/05/09/Monte%20Carlo%20Methods%20for%20Volumetric%20Light%20Transport%20Simulation</id><content type="html" xml:base="http://localhost:3798/2019/05/09/Monte-Carlo-Methods-for-Volumetric-Light-Transport-Simulation.html">&lt;h2 id=&quot;section-2-optical-properties&quot;&gt;Section 2. Optical Properties&lt;/h2&gt;

&lt;h3 id=&quot;collision-coefficient&quot;&gt;Collision Coefficient&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;density per unit volume: $\rho (m^{-3})$&lt;/li&gt;
  &lt;li&gt;cross sectional area: $\sigma_{s}, \sigma_{a} (m^2)$&lt;/li&gt;
  &lt;li&gt;scattering(absorption) coefficient: $\mu_{s}(\mu_{a})=\sigma_{s}(\sigma_{a}) \cdot \rho (m^{-1})$&lt;/li&gt;
  &lt;li&gt;extinction coefficient: $\mu_{t}=\mu_{s}+\mu_{a}$&lt;/li&gt;
  &lt;li&gt;single-scattering albedo: $\alpha=\frac{\mu_{s}}{\mu_{t}}$&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;phase-function&quot;&gt;Phase Function&lt;/h3&gt;

&lt;p&gt;Examples: Henyey-Greenstein, Rayleigh, Lorenz-Mie.&lt;/p&gt;

&lt;p&gt;For more details in &lt;em&gt;Handbook of Digital Image Synthesis: Scientific Foundations of Rendering&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3-volumetric-rendering-equation&quot;&gt;Section 3. Volumetric Rendering Equation&lt;/h2&gt;

&lt;h3 id=&quot;radiative-transfer-equation-rte&quot;&gt;Radiative Transfer Equation (RTE)&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\omega\cdot\nabla)\cdot L(x,\omega)=-\mu_{t}(x)L(x,\omega)+\mu_{a}(x)L_{e}(x,\omega)+\mu_{s}(x)L_{s}(x,\omega)&lt;/script&gt;

&lt;p&gt;Then, this differential equation can yield&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L(x,\omega)=\int_{0}^{\infty}T(x,y)[\mu_{a}(y)L_{e}(y,\omega)+\mu_{s}(y)L_{s}(y,\omega)]dt&lt;/script&gt;

&lt;p&gt;Here, $y=x-t\cdot\omega$, $T(x,y)=e^{-\int_{x}^{y}\mu_{t}(z)dz}$(Beer Lambert Law)&lt;/p&gt;

&lt;h3 id=&quot;volume-rendering-equation&quot;&gt;Volume Rendering Equation&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L(x,\omega)=\int_{0}^{dist}T(x,y)[\mu_{a}(y)L_{e}(y,\omega)+\mu_{s}(y)L_{s}(y,\omega)]dt+T(x,z)L(z,\omega)&lt;/script&gt;

&lt;p&gt;Here,$z=x-dist\cdot \omega$&lt;/p&gt;

&lt;h3 id=&quot;path-integral-formulation&quot;&gt;Path Integral Formulation&lt;/h3&gt;

&lt;p&gt;$\overline{x_{k}}={x_0,x_1,\dots,x_k}$, the $x_0$ is the point on the sensor&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(\overline{x_{k}})=W(x_0,x_1)G(x_0,x_1)T(x_0,x_1)\cdot L_{e}(x_k\rightarrow x_{k-1})\cdot \prod_{i=1}^{i=k-1}f_{s}(x_{i+1}\rightarrow x_{i}\rightarrow x_{i-1})G(x_{i},x_{i+1})T(x_{i},x_{i+1})&lt;/script&gt;

&lt;p&gt;$W$ is response of the point on the sensor&lt;/p&gt;

&lt;p&gt;$G(x,y)=\frac{D(x,y)\cdot D(y,x)}{\Vert x-y\Vert ^2}$&lt;/p&gt;

&lt;p&gt;$D(x,y)=\begin{cases} \vert n(x)\cdot \omega_{x\rightarrow y}\vert &amp;amp; \text{x is on a surface} \newline 1 &amp;amp; \text{x is in a medium} \end{cases}$&lt;/p&gt;

&lt;p&gt;$f_{x\rightarrow y\rightarrow z}=\begin{cases} f_{r}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is on a surface} \newline \mu_{s}(y)\cdot f_{p}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is in a medium} \end{cases}$&lt;/p&gt;

&lt;p&gt;$L_{e}(x\rightarrow y)=\begin{cases} L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is on a surface} \newline \mu_{a}(x)L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is in a medium}\end{cases}$&lt;/p&gt;

&lt;h2 id=&quot;section-4-distance-sampling&quot;&gt;Section 4. Distance Sampling&lt;/h2&gt;</content><author><name>slongle</name><email>junchendeng@gmail.com</email></author><category term="Computer-Graphics" /><summary type="html">Section 2. Optical Properties Collision Coefficient density per unit volume: $\rho (m^{-3})$ cross sectional area: $\sigma_{s}, \sigma_{a} (m^2)$ scattering(absorption) coefficient: $\mu_{s}(\mu_{a})=\sigma_{s}(\sigma_{a}) \cdot \rho (m^{-1})$ extinction coefficient: $\mu_{t}=\mu_{s}+\mu_{a}$ single-scattering albedo: $\alpha=\frac{\mu_{s}}{\mu_{t}}$ Phase Function Examples: Henyey-Greenstein, Rayleigh, Lorenz-Mie. For more details in Handbook of Digital Image Synthesis: Scientific Foundations of Rendering Section 3. Volumetric Rendering Equation Radiative Transfer Equation (RTE) Then, this differential equation can yield Here, $y=x-t\cdot\omega$, $T(x,y)=e^{-\int_{x}^{y}\mu_{t}(z)dz}$(Beer Lambert Law) Volume Rendering Equation Here,$z=x-dist\cdot \omega$ Path Integral Formulation $\overline{x_{k}}={x_0,x_1,\dots,x_k}$, the $x_0$ is the point on the sensor $W$ is response of the point on the sensor $G(x,y)=\frac{D(x,y)\cdot D(y,x)}{\Vert x-y\Vert ^2}$ $D(x,y)=\begin{cases} \vert n(x)\cdot \omega_{x\rightarrow y}\vert &amp;amp; \text{x is on a surface} \newline 1 &amp;amp; \text{x is in a medium} \end{cases}$ $f_{x\rightarrow y\rightarrow z}=\begin{cases} f_{r}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is on a surface} \newline \mu_{s}(y)\cdot f_{p}(x\rightarrow y\rightarrow z) &amp;amp; \text{y is in a medium} \end{cases}$ $L_{e}(x\rightarrow y)=\begin{cases} L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is on a surface} \newline \mu_{a}(x)L_{e}(x,\omega_{x\rightarrow y}) &amp;amp; \text{x is in a medium}\end{cases}$ Section 4. Distance Sampling</summary></entry></feed>